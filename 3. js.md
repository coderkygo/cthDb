---
title: Javascript详解
tags: [JS]
categories: 
- [前端, 2. JS]
---



# JS基础

## 0. 邂逅JavaScript（了解）

### 0.0 认识编程语言

- HTML-标记语言	CSS-样式语言

- HTML、CSS、JS都属于**计算机语言**（我们人和计算机进行沟通交流的语言）

- JS不仅属于计算机语言，精确来说是一门**编程语言**

- **编程语言特征**

  - 数据和数据结构(变量、数组、对象等)
  - 指令及流程控制（if/for）
  - 引用机制和重用机制
  - 设计哲学

  

### 0.1 编程语言发展历史

- 机器语言
  - 由0、1组成，也叫做机器码或二进制编码
  - 一定长度的机器码组成了机器指令，用机器指令编写的程序就是机器语言
  - 优点：直接被计算机识别，不需编译解析，直接对硬件产生作用，程序效率高
  - 缺点：可读性差、容易出错、不易编写
- 汇编语言
  - 用符号代替冗长的0、1代码（通过汇编器将汇编码转成0、1，从而被机器识别）
  - 优点：和机器语言一样，可以直接访问、控制计算机的各种硬件设备，占用内存少执行速度快
  - 缺点：代码缺乏可移植性（不同语言有不同汇编语言语法和编译器）、符号非常多难记
  - 应用场景：操作系统内核、单片机程序、驱动程序
- 高级语言
  - 高级语言就是更接近自然的语言，更符合人类的思维方式，一般使用英文编写
  - 优点
    - 简单、易用、易于理解，语法结构类似于普通英文
    - 远离对硬件的直接操作
    - 具有可移植性，一个程序可以在不同机器上运行
  - 缺点
    - 不能直接被计算机识别，需要经编译器翻译成二进制指令后，才能运行到计算机上
    - 种类繁多

### 0.2 JS的历史

- 认识JavaScript
  - JavaScript是一门高级的、解释型的编程语言
  - 是一门基于原型的、头等函数的语言，是一门多范式的语言...
  - JavaScript是前端开发的灵魂

- 1994年，网景公司（Netscape）发布了Navigator浏览器0.9版本
  - 这是历史上第一个比较成熟的网络浏览器
  - 但是这个版本浏览器只能用来浏览，不能与用户互动，网景公司急需一种网页脚本语言
- 网景公司当时想要选择一门语言来嵌入到浏览器中
  - 网景公司招募了程序员Brendan Eich，希望将Scheme语言作为网页脚本语言的可能
  - 同时发生了一件大事：1995年Sun公司将Oka语言改名Java，正式向市场推出
  - 网景公司动了心，希望和Sun公司结成联盟，将Java嵌入到网页中来运行
  - Brendan Eich本人非常热衷于Scheme，但管理层那时候有点倾向于Java
- Brendan Eich用10天时间设计出JavaScript
  - 最初这门语言得名字叫Mocha（摩卡），Navigator2.0 beta版本改名为LiveScript
  - Navigator2.0 beta 3版本正式命名为JavaScript（当时是为了给这门语言搭上Java这个热词）
  - 这门语言更像是很多语言的大杂烩
    - 借鉴C语言的基本语法
    - 借鉴Java语言的数据类型和内存管理
    - 借鉴Scheme语言，将函数提升到"一等公民"（first class）的地位
    - 借鉴Self语言，使用基于原型（prototype）的继承机制
- 微软公司于1995年首次推出Internet Explorer，从而引发了与Netscape的浏览器大战
  - 微软创建了JScript语言，这时对开发者来说是一种噩耗，因为要适配不同浏览器
- 1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准
  - 1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262
  - JavaScript成为ECMAScript最著名的实现之一（ActionScript和JScript也都是ECMAScript规范的实现语言）
- 所以说，ECMAScript是一种规范，而JavaScript是这种规范的一种实现

### 0.3 JS的组成

- JavaScript是ECMAScript标准的**语言层面**实现
- 除了语言规范外，JS还需要对页面(DOM)和浏览器(BOM)进行各种操作
- 所以JS由三大部分组成：ECMAScript、DOM、BOM

### 0.4 JS运行引擎

- 不同的浏览器由不同的内核组成，如：Webkit、Blink
- 通常我们说的浏览器内核是指：排版引擎，而JS是由JS引擎来执行的
- JS引擎
  - 为什么需要JS引擎：将JS(高级语言)=>CPU指令(机器码)来执行
  - 常见的JS引擎
    - SpiderMonkey：第一款JS引擎，由Brendan Eich开发（JS作者）
    - Chakra：微软开发，用于IE浏览器
    - JavaScriptCore：Webkit中的JS引擎，Apple公司开发
    - V8：Google开发的强大JS引擎，帮助Chrome浏览器脱颖而出
- 浏览器内核和JS引擎的关系
  - 以WebKit内核为例，由两部分组成
    - WebCore：负责HTML解析、布局渲染等
    - JavaScriptCore：解析、执行JS代码
  - 在小程序中编写的JS也是由JSCore执行的

### 0.5 JS应用场景

- Web开发（原生JS、Vue、React、Angular开发）
- 移动端开发（ReactNative、Weex）
- 小程序开发（微信小程序、支付宝小程序、uniapp、taro）
- 桌面端开发（Electron，如VSCode）
- 后端开发（Node框架，koa、express...）



## 1. JavaScript基本知识

### 1.1 JS编写方式

- 位置：行内/内部/外部引入  (外部src引入的script标签中不能写js代码，不然无效)

```html
<!-- 行内引入-HTML代码行内（不推荐） -->
<button onclick="alert('行内引入js')" href="#">点一下</button>
<button href="javascript:alert('行内引入js方式二')">点一下</button>

<!-- 内部引入-script标签中 -->
<script>
  alert("内部引入js")
</script>

<!-- 外部引入-外部js文件，通过script元素的src属性引入文件 -->
<script src="./out.js"></script>
```

- 注意点：js代码放到head，并需要通过js操作页面元素时就会失效(HTML从上至下执行)

- 解决
  - 加上window.onload=function(){ js代码 }  (内部外部都可以加)
  - 将script或script-src放到body结束标签之前

### 1.2 noscript元素

- 浏览器不支持JavaScript或者用户关闭了浏览器的JavaScirpt功能时，可以使用noscript元素

- noscript元素用于给不支持JavaScript的浏览器提供替代内容

- 注意：只有当浏览器不支持或关闭了javascript时，noscirpt元素才会起作用（显示出来）

  ```html
  <body>
    <noscript>
      <h1>您的浏览器不支持或关闭运行JavaScript</h1>
    </noscript>
  </body>
  ```

### 1.3 JavaScript注意事项

- script元素不能写成单标签
- 自动省略type属性（以前的代码script中会使用type="text/javascript"，现在不用写了）
- 加载顺序
  - 作为HTML文档的一部分，自上而下加载，**推荐将js放在body子元素的最后一行**
- js代码严格区分大小写
- script元素还有defer、async属性（后续学习）

### 1.4 JS的交互方式

- 弹窗：alert()-确定按钮  confirm()-确定取消  prompt()-确定取消获取用户输入框	

- 网页内容区域：document.write()  

- 控制台：普通console.log(a,b...)  警告console.warn()  错误console.error()

### 1.5 Chrome调试工具

- 可以在开发者工具中的console查看log出的内容
- 如果代码中出现了错误或警告，会在console中显示
- console中有个 > 符号，表示控制台的命令行
  - 在命令行中可以直接编写js代码，按下enter键执行
  - 如果想编写多行代码，按住shift+enter来换行

- 还可以通过debug方式来调试、查看代码的执行流程

### 1.6 JS的语句和分号

- 语句是向浏览器发出的指令，通常表达一个操作或行为
- 通常每条语句后都会加上一个分号，表示语句的结束
- 当存在换行符时，大多数情况可以省略分号（JS将换行符理解成"隐式"的分号，也称为自动插入分号）

### 1.7 JS的注释

- 三种注释：单行注释、多行注释、文档注释

  ```javascript
  //我是js单行注释
  
  /*我是js多行注释*/
  
  /*
  文档注释：VSCode中在单独的JS文件中编写才有效，当我们调用函数时就会有提示，快捷键："/**"，如下：
  */
  /**
   * 向某人打招呼
   * @param {string} name 姓名
   * @param {number} age 年龄
   */
  function sayHello(name,age){
    
  }
  ```

- 注意：JS不支持注释嵌套

 

## 2. ECMAScript

### 2.1 变量和数据类型

#### 2.1.1 变量

- 作用：记录某一个之后会变化的数据

- 变量定义

  - 变量声明（var关键字） + 变量赋值（=）

    ```javascript
    //声明并且赋值，也可给多个变量声明和赋值
    var age=18;
    //先声明再赋值（不推荐），没有初始化值为undefined
    var a,b;  
    a=b=213;  
    ```

- 变量(标识符)的命名规范（标识符-凡是自己命名的都叫标识符）
  - 命名规则（必须遵守）
    - 第一个字符必须是一个字母、下划线、美元符号，其他字符可以是数字、字母、下划线、美元符号
    - 不能使用关键字和保留字命名
    - 变量严格区分大小写
  - 命名规范（建议遵守）
    - 多个单词时，驼峰命名：一般小驼峰
    - = 号两边加上空格
    - 每条语句结束加上分号
    - 变量见名知意
  
- 注意
  - 变量不声明直接使用会报错
  - 变量有声明但没有赋值，值为undefined（不推荐，一般会给初始值如：0、""、null...）
  - 不使用var声明直接赋值，也可以，但不推荐（对将变量加到window对象上）

 

#### 2.1.2 数据类型

- javascript是一门"动态类型"的编程语言
  - javascript中的值都具有特定的数据类型
  - 一个变量可以在上一刻是字符串，下一个是一个数字

- 8种基本数据类型（7种原始类型/基本数据类型和1种复杂类型）

  - number string boolean
  - undefined null object(引用类型)
  - BigInt Symbol（后续了解）

- typoef操作符的使用

  - 由来：因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型

  - 用法

    ```javascript
    /*
    typeof x 因为是操作符所以中间用空格连接即可
    typeof(x) 不是一个函数，括号只是代表后面是一个整体，如：(1+2)*3
    */
    var age = 19
    console.log(typeof age)
    console.log(typeof(age))
    ```

  - 返回以下任意值之一

    - "number"、"string" 、"boolean"、 "undefined" - 未赋值
    - "object" - 对象或null
    - "function" - 函数     "symbol"- 符号

- **Number类型**

  - 范围：JS所有数值 - 整数和浮点数

  - 除了常规数字，还包括一些 "特殊数值"：Infinity、NaN（了解）

    ```javascript
    //NAN(not a number)非数值，表示一个错误操作得到的结果
    console.log(Number("123cth"),3*"abc");
    //Infinity/-Infinity（无穷大和无穷小，全局对象的属性 window.Infinity）
    console.log(1 / 0);   //Infinity  0/0=NaN
    console.log(-1 / 0);  //-Infinity
    ```

  - 数字的进制表示

    ```javascript
    //十进制
    var num1=111;
    //十六进制
    var num2=0x111;
    //八进制
    var num3=0o111;
    //二进制
    var num4=0b111;
    console.log(num1,num2,num3,num4);
    ```

  - 数字表示范围

    ```javascript
    console.log(Number.MAX_VALUE); //最大正数值
    console.log(Number.MIN_VALUE); //最小正数值，小于这个数会转化为0
    ```

  - isNaN: 判断是否不是一个数字（NAN），不是数字返回true

  - 注意：不要使用js进行精度要求较高的计算

- **String类型**

  - 用途：表示一段文本

  - 三种使用方法：单引号""、双引号''、反引号`（ES6语法）

    ```javascript
    var name="kygo"
    var name='kygo~'
    var name=`kygo~~`
    //反引号,${变量/表达式}
    var msg=`my name is ${name},age is ${17+1}`
    ```

  - 如果字符串本身使用双引号，那么字符串中可以使用单引号，反之也可

    ```javascript
    var desc="kygo is 'shuaige'"
    var desc1='kygo is "shuaige"'
    ```

  - 转义字符（了解）

    - 一些有特殊功能的字符可以通过转移字符的形式放入字符串中

    - 都是斜杠\开头

      ```javascript
      \\ 斜杠
      \n \t 换行符、制表符
      \' \"  单引号、双引号
      ```

  - 字符串的属性和方法

    - 字符串拼接：通过 + 连接

    - 获取字符串长度

      ```javascript
      var msg1 = "my name is"
      var msg2 = "kygo"
      var msg3 = msg1 + msg2
      var msg4 = `my name is ${msg2}` //推荐
      console.log(msg3,msg3.length);
      ```

- Boolean类型
  - 作用：用于表示真假
  - 值：真、假 - true/false


- Undefined类型

  - 只有一个值，就是undefined
    - 如果只声明变量没有赋值，默认值就是undefined

  - 注意
    - 最好在变量定义时进行初始化，而不是只是声明变量
    - 不要把变量显示的赋值为undefined（可以初始化为0、""、null等）

- Object类型和Null类型

  - 通常被称为引用类型或复杂类型

  - 作用：表示一组数据，是其他数据的一个集合

  - 表示方法：用花括号{}的方式来表示一个对象

    ```javascript
    var obj={
      name: "kygo",
      age: 18,
      height: 1.88
    }
    console.log(obj.name);
    ```

  - Null类型

    - 值：只有一个值null
    - 作用：通常用来表示一个对象为空，用来给一个对象进行初始化时，会赋值为null
    - 也属于object类型：使用typeof操作符返回object

  - null和undefined的关系

    - undefined通常只有在一个变量声明但未初始化时，默认值是undefined才会用到

    - 不推荐直接给变量赋值为undefined，所以很少主动来使用

    - null值非常常用，当我们变量准备保存一个对象，而对象不确定时，可以先赋值null

      

#### 2.1.3 数据类型的转换

- String类型的转换
  - 隐式类型转换：一个字符串和其他类型进行+操作
  - 显示转换：String()函数、toString()方法

```javascript
//三种方法：toString()  String()  +""
var num = 2;
console.log(String(num) + " 类型：" + typeof String(num));
console.log(num.toString() + " 类型：" + typeof num.toString());
console.log(num + "" + " 类型：" + typeof(num + ""));
/*Result
2 类型：string
2 类型：string
2 类型：string */

//toString()转换undefined与null类型会报错,toString()可以转换数字进制，在()指定
var num = 7
console.log(num.toString(2));	//进制转换 111
console.log(undefined.toString()); //报错
console.log(null.toString());	//报错
```



- Number类型的转换

  - 隐式转换：在算术运算时，通常会将其他类型转成数字类型来运行（除了+运算且一边是字符串）

  - 显示转换：Number()函数

    ```javascript
    //Number()  +  
    console.log(true + 0);  //+不能转换字符串为数字
    
    //string转number 如果不是纯数字-> NaN
    console.log("value=" + Number("123a") + " type=" + typeof Number("123a"));
    ```

  - 其他类型转数字的规则

    ```java
    //空、空格字符串/null/false都是0  undefined/非纯数字->NaN
    console.log("false:" + Number(false) + " 空:" + Number(" ") + " null:" + Number(null) 
                + " undefined:" + Number(undefined));
    //Result
    false:0 空:0 null:0 undefined:NaN
    ```

  - 扩展：parseInt/parseFloat-字符串转数字专用

    ```javascript
    /*
    parseInt() 和 parseFloat()专门用于转换非纯数字
    解析到第一个非数值为止  如parseInt(c3px) ->NaN */
    console.log("value=" + parseInt("123a") + " type=" + typeof parseInt("123a"));
    console.log("value=" + parseFloat("123.123a") + " type=" + typeof parseInt("123a"));
    ```



- Boolean类型的转换  
  - 通过Boolean()函数 或 隐式转换!!
  - 转换规则：直观上为空的值（0、""、null、undefined和NaN）都转成false

```javascript
//Boolean()  !!
console.log(Boolean("Kygo"));
console.log("Res: " + !!"kygo");
```

注意：空字符串/0/NaN/null/undefined  ->false

​    

### 2.2 运算符

- 运算符和运算元

  - 运算符：计算机最基本的操作就是执行运算，而执行运算就需要使用运算符来操作

  - 运算元
    - 运算符应用的对象
    - 一个运算符对应的只有一个运算元叫一元运算符，一个运算符对应两个运算元...

- 分类

  - 功能分：算数运算符/赋值运算符/关系(比较)运算符/逻辑运算符

  - 操作数分：单目/双目/三目运算符

#### 2.2.1 算数运算符

- 注意
  - 左结合性(从左到右计算)
  - NaN和任何运算都是NaN，都会先转换为number再计算(+""除外)
  - 取余操作：m%n=余数  m>n~余数  m<n~m  n=0~NaN  （结果正负性取决于m）


```javascript
//加减乘除、取余、幂(ES7，和Math.pow()函数类似)
+ - * / % **
```

#### 2.2.2 赋值运算符

- 优先级低于算数运算符、右结合性

```javascript
//最常用的赋值运算符：=
=   
//链式赋值，从右往左计算
var num=num1=num2=1+1
//原地修改：对一个变量做运算，并将新的结果存储到同一个变量中
+=  -=  *=  /=  %= **=
```

#### 2.2.3 自增自减运算符

- 注意
  - 自增/自减只能应用于变量，应用于数值（比如5++）会报错
  - 尽量单独出现，不推荐在表达式中写（阅读性较差）

```javascript
//n++和++n区别：n++表达式值为n, ++n为n+1
++  --  
//四种实现方法
var Index=0
index=index+1
index+=1
index++
++index
```

#### 2.2.4 关系(比较)运算符

- 注意：
  - 关系运算符返回布尔值：关系成立就返回true，不成立就返回false
  - 任何非数值类型，先转换为数值类型再判断(字符串和字符串比较除外)
  - 参与比较的都是字符串，比较对应的Unicode编码(一位一位比较Unicode)
  - 任何数据和NaN比较，返回值都是false


```javascript
//左结合性,前四个优先级高后四
>  <  >=  <=  ==  !=  ===  !==  
 
/*== 和 ===区别：===只有取值和数据类型完全相同才会返回true（完全相等）
比较不同类型时，==两侧的值会先转成数字再进行比较（null除外）
开发建议都使用===、!==来降低犯错的可能性
*/
console.log("1" == true);
console.log("1" === true);

//三种特殊比较 （了解）
null==0 false 
undefined==0 false  
null==undefined true 	//null衍生的

//判断是否是NaN，NaN==NaN(不能这样判断)  
isNaN()  
```



#### 2.2.5 逻辑运算符

- 三个逻辑运算符：&&(与)、 ||(或)、 !(非)

- 作用：将多个表达式或值放到一起来获得最终值

- 规则

  ```javascript
  &&  	//逻辑与 一假则假  
  ||  	//逻辑或 一真则真  
  !   	//逻辑非 取反
  ```

- 注意

  - 左结合性 、&&优先级高于||  
  - 不是boolean先转换为boolean再计算


- 短路现象：&&只要前面是假，后面的语句不会执行(检查)，||相反

- **逻辑与/或的本质**

  - 逻辑或的本质（返回第一个真值运算元的初始值，不存在真值就返回最后一个）
    - 从左到右依次计算操作数，处理每一个运算元时都将其转成布尔值
    - 一旦遇到某个运算元结果是true则停止计算，返回这个运算元的**初始值**
    - 如果所有运算元都被计算过（转换结果是true），则返回最后一个
  - 逻辑与的本质：返回第一个假值的运算元初始值，不存在返回最后一个
  - 注意：返回的值是运算元的初始形式，不会转化为Boolean类型

  - 总结：返回第一个能够决定表达式真假的运算元，如果没有则返回最后一个

- 逻辑与、或在开发中的应用

  ```javascript
  //逻辑或-获取第一个有值的结果
  var info="123"
  var message=info||"默认值"
  
  //逻辑与-对一些对象中的方法进行有值判断
  var obj={
    name: "Kygo",
    age: 18,
    sayHello(){
      console.log("hello");
    }
  }
  //调用sayHello函数
  obj && obj.sayHello && obj.sayHello()
  ```

- 逻辑非 !

  - 接收一个参数，先将操作数转为布尔类型，再返回取反的值
  - 应用：两个非运算符!!用来将某个值转为布尔类型



- 其他运算符

  - 三元运算符：条件表达式 ? 结果A : 结果B  true-返回A

    ```javascript
    //常见用法：如果info有值就使用info，否则给个默认值
    info={name: "kygo"}
    var obj = info ? info : {}
    ```

  - 逗号运算符：简化代码/优先级最低/左结合性/运算结果是最后一个表达式结果

  - 单目运算符：typeof/+/ -  +可用于隐式类型转换为number  



### 2.3 流程控制

- 流程控制基本知识
  - 程序的执行顺序：顺序结构、选择(分支)结构、循环结构
  - 代码块{}
    - 多行代码的集合，通过一个花括号{}放到一起
    - 可以通过流程控制语句来指定如何执行一个代码块

#### 2.3.1 选择结构（分支语句）

- if 分支语句、if else多分支语句、if  else if ... else多分支语句
- switch分支语句
  - 通过判断表达式结果（或变量）是否等于case语句的常量
  - if可以做值的范围判断，switch语句只能做值的相等判断（全等===）

- 注意
  - 如果代码块中语句只有一行，花括号{}可以省略
  - ()括号内的表达式会自动转成布尔类型来判断是否执行代码块

- if/switch如何选择：对区间判断用if  对固定值判断用switch（能用if就用if）

```javascript
//只有一个会执行非布尔先转布尔再判断 
if / if else / if  else if ...  else 

/*
switch语句中至少有一个case代码块和一个可选的default代码块
case穿透问题：一条case语句执行完后会自动指定下一条，使用break解决
break关键字：结束整个switch语句，一般在每个case后都加
case判断的是===  ()和case的表达式可以是常量/变量/表达式
default可以省略且不一定在最后（一般放在最后）
*/
switch(表达式/变量){
  case 常量1: 
    //语句一
    break 
  case... 
  default: 
    //语句n
}  
```



#### 2.3.2 循环结构（循环语句）

- 重复运行同一段代码的方法，对列表进行循环操作也叫遍历或迭代
- 三种循环方式：while、do-while、for
- 注意
  - 尽量避免条件一直成立，造成死循环
  - for中用let定义的i只能在for中使用,变量作用域-let定义的变量在{}中有局部作用域
  - 循环是可以嵌套的

- 循环控制-break/continue关键字
  - 作用：终止循环的执行，可以是某次循环或直接结束整个循环
  - break：跳出当前循环
  - continue：本次循环不再执行continue后面的代码，跳入下次循环

- 使用场景：在不知道具体循环次数的时候用while（for循环更加灵活，能用for就用for）

```javascript
//执行顺序：先执行begin(只执行一次)，然后进行迭代（先判断condition，成立再执行body，然后step...）
for(begin;condition;step){
  //循环代码块
}
//条件成立执行代码块，不成立不执行
while(循环条件){
  //循环代码块
}
//不管条件成不成立，都会先执行一次循环  
do{
	//循环代码块 
}while(循环条件)
```

 

### 2.4 函数

#### 2.4.1 认识函数

- 程序中的foo、bar、baz

  - 作用：经常用作函数、变量、文件的名称，本身没有特殊意义

- 什么是函数

  - 已经学习过的函数：alert、prompt、consloe.log、Number...
  - 作用：用于封装一段可以随时反复执行的代码块
  
  

#### 2.4.2 函数的使用步骤

  - 声明函数(定义函数) ：是对某些功能的封装过程

  - 调用函数：调用自己封装好的某个函数，也可调用默认提供的或第三方库定义好的函数

    ```javascript
    //使用关键字function声明函数，()调用函数
    function fun(形参列表){... return;}  
    fun();
    ```

  - 注意
    - 函数命名规则和变量一样，定义完函数是不会执行的，必须通过()调用才会执行
    - 形参和返回值可有可无，无返回值默认返回undefined
    - return语句和break语句一样后面不要跟代码，永远不会执行
    
  - 函数的参数
    - 形参(parameter)：定义函数时，小括号中的参数，用来接收参数用的，在函数内部作为变量使用
    - 实参(argument)：调用函数时，小括号中的参数，用来把数据传递到函数内部用的
    
  - 函数的返回值
    - 使用return关键字来返回结果
    - 一旦在函数中执行return，当前函数会终止
    - 没有使用return或return后什么也不跟，都是返回undefined

- arguments变量(JS高级学习)

  - 由来：arguments对象是所有(非箭头)函数中都可用的局部变量
  - 作用：该对象中保存所有传递给函数的实参（从0位置开始，依次存放）
  - 注意：arguments变量类型是object(array-like)，不是一个数组
  
  

#### 2.4.3 函数的递归

  - 作用：将一个复杂的任务，转换成可以重复执行的相同任务

  - 函数自己调用自己的过程就叫做递归-Recursion（必须有结束条件，否则会无限调用，造成报错）

  - 练习

    - 用递归实现一个自己的幂函数pow

    ```javascript
    //x的n次幂: pow(x,n)=x * pow(x,n-1)
    function pow(x,n){
      if(n === 1) return x
      return x * pow(x,n-1)
    }
    ```

    - 实现斐波那契数列（使用递归和不使用递归都实现一编）
      - 某一个数是前两个数的和：1 1 2 3 5 8 13 21... （第一第二个数都是1）
      
      

#### 2.4.4 函数作用域

  - 什么是作用域：变量在某一个范围内可以使用

  - 由来：在JS(ES5之前-var定义的)中没有块级作用域的概念，但是函数可以定义自己的作用域

  - 函数作用域定义：函数作用域表示在函数内部定义的变量，只有在函数内部才能访问到

  - 外部变量、局部变量
    - 局部变量：定义在函数内部的变量
    - 外部变量：定义在函数外部的变量（在a函数外，但可能在其他函数中，叫做a的外部变量）
    
  - 全局变量
    - 范围：在所有函数外部(script中)声明的变量
    - 全局变量在任何函数中都是可见的
    - 通过var声明的全局变量会在window对象上添加一个属性
    
  - 函数中的变量访问顺序
    - 优先访问自己函数中的变量=>没有找到就依次往外部找
    - 外部函数里也没有=>window对象=>没有定义报错
    
  - 后续学习的：块级作用域、作用域链、变量提升、AO VO GO

    

#### 2.4.5 函数表达式

- 函数的另外一种定义方式 - 函数表达式

  - 函数也是引用数据类型(对象)，所以可以保存到变量中
  - function 后面一般省略函数名
  - 无论怎么创建函数，函数都是一个特殊的值，值类型是一个对象

  ```javascript
  var foo = function() {...}
  foo()
  ```

- 函数声明 VS 函数表达式

  - 语法不同：函数声明是单独的语句声明函数，函数表达式是在表达式或另外的语句中创建函数

  - JS内部创建函数的时机不同

    - 函数表达式是代码执行到的时候函数才被创建，函数仅从那一刻开始可用

    - 当JS准备运行脚本时，会在脚本寻找全局函数声明，并创建这些函数，然后再去运行脚本

      ```javascript
      foo()  //可以成功调用foo函数，因为JS引擎在执行js脚本前会提前创建全局声明的函数
      function foo() {...}
      
      bar()  //报错，找不到bar，因为是使用函数表达式创建函数，属于表达式，不会提前创建函数
      var bar = function() {...}
      ```

  - 开发选择：首先考虑函数声明语法，因为它更加灵活 - 可以在声明函数前就调用这些函数

    

#### 2.4.6 头等函数

- 定义：是指在程序设计语言中，函数被当做头等公民

  - 函数可以作为**别的函数的参数、返回值、赋值给变量或存储在数据结构中**

- 函数式编程 - 函数作为头等公民的编程方式

- 头等函数的体现

  - 函数可以被赋值给变量 - 函数表达式写法就是它的一种体现

    ```javascript
    function foo() {...}
    var bar = foo
    bar()
    ```

  - 函数作为另外一个函数的参数、返回值

    ```javascript
    function bar(){...}
    function foo(fn){
      fn()
      function baz(){...}
      //函数作为返回值
      return baz
    }
    //函数作为参数传递
    foo(bar)
    ```

  - 将函数存储在另外一个数据结构中

    ```javascript
    var foo = {
      name: "kygo",
      running: function(){...}
    }
    foo.running()
    ```

    

#### 2.4.7 回调函数

- 函数回调的理解（Callback Function）

  - 函数作为参数传递到另外一个函数内部，通过参数去调用函数称为函数的回调

    ```javascript
    function bar(){...}
    function foo(fn){
      //通过fn去调用bar的过程称为函数的回调
      fn()
    }
    foo(bar)
    ```

- 函数回调的案例

  - 需求：通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果

  - 因为拿到结果需要一定的时间，所以我们可以传入一个回调函数

    ```javascript
    function request(url,callback){
      console.log("通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果")
      //假如拿到了结果
      var resultList = ["JS", "Vue", "React"]
      callback(resultList)
    }
    function handleResult(res){console.log("在handleResult中拿到的结果:",res)}
    //传入函数，拿到结果
    request("http://www.baidu.com/abc/getResult", handleResult)
    
    /*-----------代码重构--------------*/
    function request(url,callback){
      console.log("通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果")
      //假如拿到了结果
      var resultList = ["JS", "Vue", "React"]
      callback(resultList)
    }
    //传入的函数是没有名字的 - 匿名函数
    request("http://www.baidu.com/abc/getResult", function(res){
      console.log("在handleResult中拿到的结果:",res
    })
    ```

- 高阶函数和匿名函数

  - 高阶函数至少满足两个条件
    - 接受一个或多个函数作为输入
    - 输出一个函数
    
  - **匿名函数**
    
    - 如果在传入一个函数时，我们没有指定这个变量的名称或通过函数表达式创建函数就称为匿名函数
    - 应用：匿名函数经常作为其他函数的参数或返回值
    
    

#### 2.4.8 立即执行函数

- 什么是立即执行函数

  - 专业名字：IIFE - Immediately-Invoked Function Expression（立即调用函数表达式）

  - 含义：函数定义完后立即执行

    ```javascript
    //匿名函数 + ()
    (function(){
      console.log("我是一个立即执行函数")
    })()
    ```

- 立即执行函数的作用
  
  - 立即执行函数中定义的变量有自己的作用域 - 函数作用域
  - 会创建一个函数作用域，可以避免外界访问或修改内部变量
  
- 应用场景

  - 场景一：ES6之前的协同开发就是使用这种方式-防止全局变量的命名冲突

    ```javascript
    //应用一: 有自己的函数作用域,可以防止变量的命名冲突
    var kygoModule = (function() {
      //定义要对外暴露的对象
      var kygoModule = {}
      
      var name = "kygo"
      var age = 18
      
      //将外界需要用到的变量和函数添加到对象上
      kygoModule.age = age
      return kygoModule
    })()
    //只能通过暴露的对象访问
    console.log(kygoModule.age)
    ```

  - 场景二：获取所有按钮的监听点击

    ```javascript
    //应用二: 遍历按钮并依次添加点击事件,要求打印出第n个按钮被点击了
    //问题: 每次点击任意按钮都会打印出: 第4个按钮被点击了
    var Eles = document.querySelectorAll(".btn")
    for (var i = 0; i < 3; i++) {
      Eles[i].onclick = function() {
        console.log(`我是第${i + 1}个按钮`)
      }
    }
    
    //重构代码: 使用立即执行函数的函数作用域解决问题
    //也可以直接使用let定义i就可解决问题
    var Eles = document.querySelectorAll(".btn")
    for (var i = 0; i < 3; i++) {
      //这里光光使用立即执行函数包裹是不行的,需要每次传递i进入立即函数作用域中
      (function(j){
        Eles[i].onclick = function() {
        console.log(`我是第${j + 1}个按钮`)
      }
      })(i)
    }
    ```

- 立即执行函数的其他写法

  - 立即执行函数必须是一个表达式（整体），不能是一个函数声明

    ```javascript
    //错误的写法，这种情况()前面的会被当做函数声明，因为不是一个整体
    function(){...}()
    //正确写法，()前面会被当做一个表达式
    (function(){...})()
    //其他写法(了解即可)
    +function(){...}()
    ```




### 2.5 对象

#### 2.5.1 对象的基本使用

- 为什么需要对象类型？

  - 基本数据类型可以存储一些简单的值，但是当需要存储比如：一辆车的信息，一个人的信息
  - 对象类型就是将一类事物的特征和行为组织到了一起

- 对象类型的语法和使用

  - 使用{Key: Value}  键值对的方式来表示对象

  - 键值对可以是：属性、方法

  - Key是字符串（我们一般省略引号不写）

  - value可以是任意类型：基本数据类型、函数、对象等

    ```javascript
    //创建一个对象
    var foo = {
      name: "kygo",
      running: function(){
        console.log("I am Running!")
      },
      "my friend": {  //不推荐这样写，只是为了验证key是字符串
        name: "kobe",
        age: 30
      }
    }
    ```

- 函数和方法

  - Function  通过function默认定义的结构就是函数
  - Method  将一个函数放到对象中作为对象的一个属性，那么这个函数称为方法

#### 2.5.2 对象的创建方式

- 创建对象的三种方法

  ```javascript
  //方式一: 对象字面量创建
  var foo = {
    name: "kygo"
  }
  
  //方式二: 通过new Obj创建
  var foo1 = new Object()
  foo1.name = "kygo1"
  
  //方式三: 通过其他类创建
  function Bar(){}
  var foo2 = new Bar()
  ```

  

#### 2.5.3 对象的常见操作

- 对象属性、方法的增删改查

  ```javascript
  var foo = {}
  //增加
  foo.name = "kygo"
  foo.age = 18
  foo.bar = function(){}
  
  //删除 delete操作符
  delete foo.age
  
  //修改（没有属性增加，有属性修改）
  foo.name = "kygo1"
  
  //查询
  console.log(foo.name)
  ```
  
- 对象的方括号使用

  ```javascript
  //操作对象属性另一种方式:对象["属性名"]=属性值 (属性名可不遵守规则)
  var baz = {
    name: "kygo",
    "my friend": "kobe",
    "eating something": function(){}
  }
  
  console.log(baz["my friend"])
  //将字符串保存在变量中,通过[]使用属性、调用方法
  var nameKey = "name",eatKey = "eating something"
  console.log(baz[nameKey])
  baz[eatKey]()
  ```

  

#### 2.5.4 对象的遍历

- 两种遍历对象的方式

  - 遍历/迭代：获取对象的所有属性和方法
  - Object.key(obj) 会返回一个对象的属性名组成的数组

  ```javascript
  var foo = {
    name: "kygo",
    age: 18,
    height: 1.88
  }
  
  //普通for循环遍历: 先拿到对象的属性名和属性个数-object.keys
  var keys = Object.keys(foo)
  for (var i = 0; i < keys.length; i++) {
    console.log(`${keys[i]}: ${foo[keys[i]]}`)
  }
  
  //for...in遍历对象,item会依次拿到每个属性名
  for(var key in foo){
    console.log(`${key}: ${foo[key]}`)
  }
  ```

  - 注意：for...of遍历默认不支持对象遍历（for...of只支持可迭代对象的遍历）

#### 2.5.5 JS内存分配

- 堆内存heap和栈内存stack
  - 程序是需要加载到内存中执行的，而内存可以分为堆内存和栈内存
  - 原始类型占据的空间是在栈内存中分配的
  - 对象类型占据的空间是在堆内存中分配的

- 值类型和引用类型

  - 值类型：原始数据类型在变量中保存的是值本身

  - 引用类型：对象类型在变量中保存的是对象的 "引用"

    ```javascript
    //bar存储在栈内存中，保存的是值类型
    var bar = "kygo"
    
    //foo对象是分为两个地方存储
    //{...}对象存储在堆内存中: 假如内存地址是0X110
    //在栈内存中会存储对象的引用: foo = 0X110 来指向对象
    var foo = {
      name: "kygo",
      age: 18
    }
    ```

- 一些现象的解释

  ```javascript
  //现象一： 引用类型的比较
  var foo = {}
  var foo1 = {}
  console.log(foo === foo1)//false
  
  //现象二： 引用类型的赋值
  var bar = {
    name: "kygo",
    friend: {
      name: "kobe"
    }
  }
  var friend = bar.friend
  friend.name = "kobe1"
  console.log(bar.friend.name)//kobe1
  
  //现象三： 值传递
  var b = 213
  function baz(arg) {
    arg = 318
  }
  baz(b)
  console.log(b)//213
  
  //现象四： 引用传递，但是在函数中创建了一个新对象，没有对传入对象进行修改
  var obj = {
    name: "kygo"
  }
  function foo2(obj) {
    obj = {
      name: "kobe"
    }
  }
  foo2(obj)
  console.log(obj)//"kygo"
  
  //现象五： 引用传递，但是对传入的对象进行了修改
  var obj1 = {
    name: "kygo"
  }
  function foo3(obj) {
    obj.name = "kobe"
  }
  foo3(obj1)
  console.log(obj1)//"kobe"
  ```

  

#### 2.5.6 函数中的this指向

- 什么是this

  - 函数中有一个this的变量，大多数情况下this会指向一个对象

- this的指向

  - 以默认的方式调用一个函数，this指向window

  - 通过对象调用，this指向调用的对象

    ```javascript
    //普通函数声明的this
    function foo() {
      console.log(this)
    } 
    foo() //指向window
    
    //方法的调用（通过对象调用）
    var bar = {
      baz: function() {
        console.log(this)
      },
      friend: {
        name: "kobe",
        running: function(){
          console.log(this)
        }
      }
    }
    //谁调用this就指向谁
    console.log(bar.baz())  //指向bar对象
    bar.friend.running()  //指向bar.friend对象
    
    
    //考验题目一
    var baz = bar.baz
    baz() //  this指向window对象
    //考验题目二
    function fun() {
      console.log(this)
    }
    var foo1 = {
      name: "kygo",
      fun: fun
    }
    foo1.fun()  //this指向foo1
    ```

- this的应用

    ```javascript
    var foo = {
      name: "kygo",
      age: 18,
      running: function(){
        //没有this的情况
        console.log(`${foo.name} is running! age is ${foo.age}`)
        //使用this
        console.log(`${this.name} is running! age is ${this.age}`)
      }
    }
    foo.running()
    ```

    


#### 2.5.7 构造函数和类

- 创建一系列相似对象的方式

  - 在开发中需要创建一系列的相似对象，如一系列的学生对象
  - 一种方法是直接创建一系列对象，但是这样重复代码太多
  - 第二种方法是封装一个函数用于创建对象 - 工厂函数
  - 第三种方法就是使用构造函数

  ```javascript
  //方式一: 挨个创建
  var obj1 = {}
  var obj2 = {}
  
  //方式二: 工厂函数创建对象，缺点-打印的对象都是Object类型
  function foo(name, age, heigt) {
    var obj = {}
    obj.name = name
    obj.age = age
    obj.height = heigt
    return obj
  }
  var foo1 = foo("kygo", 18, 1.88)
  var foo2 = foo("kobe", 30, 1.98)
  console.log(foo1, foo2)
  ```

- 认识构造函数

  - 构造函数也称为构造器constructor，是我们在创建对象时会调用的函数
  - 在其他编程语言中，构造函数其实是类中的一个方法，称之为构造方法
  - JS中的构造函数有点不太一样，构造函数扮演了其他语言中类的角色
  - ES5之前，都是通过function来声明一个构造函数(类)，之后通过new关键字来对其调用
  - ES6之后，JS可以向别的语言一样，通过class来声明一个类
  - 类和对象的关系：类是一类事物的统称(如：水果)，而对象是具体的体现（如：苹果）


- 类(ES5)

  - JS中的类的表示形式就是构造函数，构造函数===类
  - 构造函数
    - 构造函数也是一个普通的函数，表现形式和其他函数没有任何区别
    - 如果一个普通函数使用new操作符来调用了，这个函数就称为构造函数
  - 函数被new操作符调用了，会执行以下操作（了解）
    - 在内存中创建一个新的空对象
    - 这个对象内部的[prototype]属性会被赋值为该构造函数的[prototype]属性
    - 构造函数内部的this，会指向创建出来的新对象
    - 执行函数的内部代码
    - 如果构造函数没有返回非空对象，则返回创建出来的新对象
  - 构造函数的补充
    - 构造函数的名称：使用大驼峰

- 创建对象的方案 - 类

  - 构造函数可以确保创建的对象是Person类型的(实际是constructor属性)

    ```javascript
    //构造函数创建对象
    function Person(name, age, height) {
      this.name = name
      this.age = age
      this.height = height
      this.running = function() {
        console.log(`my name is ${name}`)
      }
    }
    var person1 = new Person("kygo", 18, 1.88)
    var person2 = new Person("kobe", 30, 1.98)
    console.log(person1, person2)
    ```

  - 构造函数的其他特征（JS高级）

    - 原型、原型链、实现继承的方案
    - ES6中的类、继承的实现

#### 2.5.8 全局对象window

- 由来

  - 浏览器中有一个全局对象window

- 作用

  - 查找变量最终会查找到window上

  - 将一些浏览器全局提供给我们的变量、函数、对象，放在window对象上

  - 使用var定义的变量会被默认添加到window上面

    ```javascript
    console.log(window)
    
    console.log(window.console === console)  //true
    console.log(window.document === document)  //true
    
    var foo = 213, bar = {}
    console.log(window.foo, window.bar === bar) //213 true
    ```

#### 2.5.9 函数也是对象

- 函数也是引用类型，存储在堆内存中

  - 虽然typeof函数结果为function，但是function类型都是对象

  ```javascript
  //foo中存储的是函数的内存地址,如0X101
  //栈内存存储：foo = 0X101  堆内存中存储： function(){} 内存地址为0X101
  var foo = function(){}
  //将foo中存储的内存地址赋值给bar
  var bar = foo
  //通过内存地址来调用堆内存中的函数
  bar()
  foo()
  
  console.log(typeof foo)  //function => Object
  //地址-指针-引用
  //定义对象类型的变量,obj/foo/bar都是存储在堆内存中的
  var obj = {}
  var foo = function(){}
  function bar(){}
  ```



### 2.6. 常见内置类

- 内置类：默认javascript已经给我们封装好的类(构造函数)，我们只需要去使用即可

#### 3.1 认识包装类型

- JS的原始类型并非对象类型，从理论上来说是没办法获取属性和方法的

- 奇怪的现象

  - 我们可以看到原始类型调用了属性和方法

    ```javascript
    var msg = "hello world"
    console.log(msg.length) //11
    console.log(msg.split(" ")) //['hello','world']
    
    var num = 3.14159
    console.log(num.toFixed(2)) //3.14
    ```

  - 现象解释：JS为了其可以调用属性和方法，封装了对应的包装类型（String、Number）

- 常见的包装类型

  - String、Number、Boolean、Symbol、BigInt类型

- 包装类型的使用过程

  - 默认情况，当我们调用一个原始类型的属性或者方法时，会进行以下操作

  - 通常JS引擎会做很多优化：它可以跳过创建包装类过程，在内部直接完成属性的获取或方法调用

    ```javascript
    var num = 3.14159
    console.log(num.toFixed(2)) //3.14
    
    //js内部做了以下操作
    //1.根据原始值，创建一个原始类型对应的包装类型对象
    var numObj = new Number(num)
    //2.调用对应的属性和方法，返回一个新的值
    var result = numObj.toFixed(2)
    //3.创建的包装类对象被销毁
    console.log(result)
    ```

    

#### 3.2 数字包装类Number

- 属性的补充
  - 最大/小安全整数
    - Number.MAX_SAFE_INTEGER/Number.MIN_SAFE_INTEGER
- 实例方法的补充
  - toString([base])
    - 数字转字符串，并且按照base进制转化
    - 注意：直接对数字操作需要使用..运算符(如：123..toString())
  - toFixed(digits)
    - 格式化数字，保留digits位小数，返回字符串(注意)
- 类方法的补充
  - Number.parseInt(string [, base]) 字符串转整数，也有对应的全局方法parseInt
  - Number.parseFloat(string)  字符串转浮点数，也有全局方法parseFloat
- 其他方法用到查MDN即可
  - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number

- 程序示例

  ```javascript
  //数字静态属性
  console.log(Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER)
  console.log(Number.MAX_VALUE, Number.MIN_VALUE)
  
  //实例方法: toString/toFixed
  var num = 213
  console.log(num.toString(8), typeof num.toString(8))  //325 string
  console.log(123..toString(), 123.321.toFixed(1))  //123 123.3
  
  var num1 = 213.318
  console.log(num1.toFixed(2), typeof num1.toFixed(2))  //213.32 string
  
  //静态方法/全局对象方法 parseInt/parseFloat
  console.log(Number.parseInt("213aaa"))  //213
  console.log(Number.parseFloat("213.318bbb"))  //213.318
  //同一个方法
  console.log(Number.parseInt === parseInt) //true
  ```

  

#### 3.3 数学对象Math

- Math对象简单认识

  - 除了Number类可以对数字进行处理外，JS还提供了一个Math对象
  - Math是一个内置对象（不是一个构造函数），它有一些数学常数属性和数学函数方法

- Math常用属性

  - Math.PI - 圆周率

- Math常见方法

  - Math.floor - 向下取整
  - Math.ceil - 向上取整
  - Math.round - 四舍五入取整
  - Math.random - 生成[0,1)的随机数
  - Math.pow(x,y) - 返回x的y次幂

- 其他方法见MDN

  - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math

- 程序示例

  ```javascript
  //静态属性
  console.log(Math.PI)  //3.14159...
  
  //静态方法
  console.log(Math.floor(3.14)) //3
  console.log(Math.ceil(3.14))  //4
  
  console.log(Math.round(2.4))  //2
  console.log(Math.round(2.5))  //3
  
  console.log(Math.pow(2,3))  //8
  
  console.log(Math.random())
  //获取任意区间随机数 m~n x=n-m y=m   
  //Math.floor(Math.random() * x + y)
  //100个[10,100)的数字
  for(var i = 0; i < 100; i++){
    console.log(Math.floor(Math.random()* 90 + 10))
  }
  ```

  

#### 3.4 字符串包装类String

- String类的基本使用

  - 开发中，我们经常需要对字符串进行各种操作，String类给我们提供了对应的属性和方法
  - String类常见属性
    - length - 获取字符串长度
  - 访问字符串的字符
    - 方法一：字符串索引 arr[0]
    - 方法二：通过str.charAt(pos)方法
    - 区别：索引方式没有找到会返回undefined，charAt没有找到会回空字符串
  - 字符串的遍历
    - 方法一：普通for循环
    - 方法二：for...of遍历

- 修改字符串

  - 字符串的不可变性
    - 字符串定义后是不可修改的，如：str[1] = "A" 不会起作用
  - 以下修改字符串的方法，都是返回新的字符串（不修改原字符串）
    - toLowerCase() - 将所有字符串转为小写
    - toUpperCase() - 将所有字符串转为大写

- 代码示例

  ```javascript
  var str = "Hello World!"
  //获取字符串长度
  console.log(str.length)  //12
  //访问字符串字符
  console.log(str[4])  //o
  console.log(str.charAt(4))  //o
  console.log(str[100], str.charAt(100))  //undefined ''
  //字符串的遍历
  //普通for遍历
  for (var i = 0; i < str.length; i++) {
    console.log(str[i])
  }
  //for...of 迭代器遍历
  //目前支持可迭代对象: 字符串/数组(对象不支持)
  //String对象内部把字符串变成了一个可迭代对象
  for (var char of str) {
    console.log(char)
  }
  
  //修改字符串
  str[0] = 'c'
  console.log(str)  //字符串不可变性,这样操作无意义
  //两个转小写大写方法(重要)
  console.log(str.toLowerCase())  //hello world!
  console.log(str.toUpperCase())  //HELLO WORLD!
  ```

  

- 查找字符串

  - 开发中经常会在一个字符串中查找或获取另外一个字符串
  - 方法一：查找字符串位置
    - str . indexOf(searchValue [, fromIndex])
    - 方法解释：从fromIndex开始，查找searchValue的索引，没有找到返回-1
    - 相似方法：lastIndexOf，从最后开始查找（用得较少）
  - 方法二：是否包含字符串
    - str . Includes (searchString [, position])    (ES6中新增方法)
    - 从position位置开始查找searchString，返回true或false
  - 方法三：以XXX开头
    - str . startsWith(searchString [, position])
    - 从position位置开始，判断字符串是否以searchString开头(ES6 新增方法)
  - 方法四：以XXX结尾
    - str.endsWith(searchString[, length])
    - 在length长度内，判断是否以searchString结束
  - 方法五：替换字符串
    - str.replace(regexp|substr, newSubStr|function)
    - 查找substr字符串(也可使用regexp正则表达式)，使用新的字符串替换(也可传入函数替换)

  ```javascript
  var str = "Hello World!"
  //indexOf/lastIndexOf查找字符串(没有找到返回-1)
  console.log(str.indexOf("llo"))  //2
  console.log(str.indexOf("He", 2))  //-1 
  console.log(str.lastIndexOf("He"))  //0
  //includes是否包含字符串
  console.log(str.includes("lo"))  //true
  console.log(str.includes("lo", 5))  //false
  
  //以XXX开始,XXX结尾
  console.log(str.startsWith("llo"))  //false
  console.log(str.startsWith("llo", 2))  //true
  console.log(str.endsWith("ld!"))  //true
  
  //字符串的替换
  console.log(str.replace("o", "cth"))  //Hellcth World!
  //将o替换为大写O
  console.log(str.replace("o", function(){
    return "O"	//返回的值即替换的值
  }))
  ```

  

- 获取子字符串（开发推荐slice方法）

  - slice(start, end)    [start, end) 切割字符串，获得子串
  - substring(start, end)    [start, end) 切割字符串
  - substr(start, length)    从start开始获取长度为length的字符串

  ```javascript
  var str = "hi kygo!"
  //三种获取子字符串的方法
  //推荐slice,支持负数(从右往左数)
  console.log(str.slice(3, 7))  //kygo  [3,7)
  console.log(str.slice(0, -1))  //hi kygo  [0,-1)
  console.log(str.substring(3, 7))  //kygo  [3,7)
  //第三个位置开始,截取4个字符
  console.log(str.substr(3, 4))  //kygo
  ```

  

- 其他方法

  - 拼接字符串

    - str.concat(str2[,...strN])

  - 删除首尾空格

    - str.trim()

  - 字符串分割

    - str.split([separator[, limit]])
    - 以separator分割，也可是一个正则表达式，limit限制返回分割后片断的数量

    ```javascript
    //拼接字符串: +/concat
    console.log(str.concat("go").concat("go").concat("go!"))  //链式调用
    console.log(str.concat("gogogo", "!"))  //hi kygo!gogogog
    
    //删除字符串首尾空格
    console.log(" ky  go ".trim())  //ky  go
    
    //字符串分割,默认每个字母为单位分割
    var str1 = "ab-cd-ef-gh"
    var items = str1.split("-")
    var newStr1 = items.join("*") //数组的join
    console.log(items)  //['ab', 'cd', 'ef', 'gh']
    console.log(newStr1)  //ab*cd*ef*gh
    ```

    

- MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String

  

#### 3.5 Date类型的使用

- 时间的表示方式（了解）

  - 最初通过观测太阳的位置决定时间，缺点：不同区域位置使用的时间不同
  - 之后开始制作标准时间：英国伦敦格的皇家格林威治天文台的标准时间(GMT)
    - 以本初子午线为标准（经度0度）
    - 其他时区根据地理位置确定：往东的时区(GMT+hh:mm)  往西的时区(GMT-hh)
  - 但是公转有一定误差，所以造成GMT的时间有一定误差，于是提出了根**据原子钟计算的标准时间UTC**
  - 目前GMT依然在使用，主要表示某个时区中的时间，而UTC是标准的时间
  - 举例：中国在UTC往东(东八区)，所以北京标准时间是在UTC时间上加8小时

- Date对象的创建

  - JS中使用Date来表示和处理时间

  - Date构造函数用法

    ```javascript
    //1. 没有传入获取当前时间
    var date1 = new Date()
    console.log(date1)
    //2. 传入时间字符串获取时间
    var date2 = new Date("2023-02-18")
    console.log(date2)
    //3. 传入Unix时间戳获取时间
    var date3 = new Date(1321331211312)
    console.log(date3)
    //4. 依次传入 年月日时分秒毫秒 获取时间
    var date4 = new Date(2023,2,18,14,54,10,123)
    console.log(date4)
    ```

    

- dateString时间的表示方式

  - RFC 2822标准

    - 默认打印的时间格式就是RFC标准的：new Date()

  - ISO 8601标准

    - 转成ISO标准：new Date().toISOString()
    - YYYY-MM-DDTHH:mm:ss.sssZ    （T用于分隔可省略，Z表示时区，SSS表示毫秒）

    ```javascript
    //时间格式
    var date = new Date()
    console.log(date) //Sat Feb 18 2023 15:01:14 GMT+0800 (中国标准时间)
    console.log(date.toISOString()) //2023-02-18T07:01:14.835Z
    ```

    

- Date获取信息的方法

  - 从Date对象中获取各种详细的信息

  - getFullYear()  getMonth()  getDate()    获取年月日(注意：月份是0-11)

  - getHours()  getMinutes()  getSeconds()  getMilliseconds   获取时分秒毫秒

  - getDay()    获取一周中的第几天，从0(周天)-6(周六)

    ```javascript
    //date获取信息方法
    var nowDate = new Date()
    console.log(nowDate.getFullYear())  //2023
    console.log(nowDate.getMonth())  //1 (当前是2月)
    //获取当前是一周的第几天
    console.log(nowDate.getDay())  //6 (星期六)
    ```

    

- Date的设置方法

  - setFullYear...（get方法也有对应的set方法）

  - 不同的是setFullYear(year,[month],[date])、setHours(hour,[min]...)可以设置多个参数

  - setTime(milliseconds)    传入时间戳设置时间

    ```javascript
    //date的设置方法
    var setDate = new Date()
    setDate.setFullYear(2050) 
    console.log(setDate)  //Fri Feb 18 2050 15:10:19 GMT+0800 (中国标准时间)
    ```

    

- Date获取Unix时间戳

  - Unix时间戳：一个整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数

  - JS中，有多个方法可以获取到时间戳

    - new Date().getTime()
    - new Date().valueOf()
    - Date.now()
    - +new Date()  算数运算符自动转换

  - 获取到Unix时间戳后，可以用作测试代码性能(运行时间)

    ```javascript
    //Date获取Unix时间戳
    var unixDate = new Date()
    //将一个date对象转成时间戳
    console.log(unixDate.getTime())
    console.log(unixDate.valueOf())
    //获取当前时间戳
    console.log(Date.now())
    console.log(+unixDate)  //不推荐
    
    //计算操作所花时间
    var startTime = Date.now()
    for (var i = 0;i < 10000; i++) {
      console.log(i)
    }
    var endTime = Date.now()
    console.log(endTime - startTime)  //147ms
    ```

    

- Date.parse方法

  - 作用：将时间字符串转为时间戳
  - 注意
    - 作用等同于new Date(dateString).getTime()操作
    - 需要符合RFC或ISO日期格式的字符串，如：YYYY-MM-DDTHH:mm:ss:sssZ
    - 如果输入的格式不能被解析，则返回NaN

  ```javascript
  //字符串转时间戳
  console.log(Date.parse("2023-3-18"))
  //以上方法和以下方法同样的效果
  console.log((new Date("2023-3-18")).getTime())
  console.log((new Date("2023-3-18")).valueOf())
  ```

  

### 2.7 数组Array使用详解(内置类)

- 什么是数组
  - 可以通过索引来访问的有序集合叫做数组，通过[]创建
  - 数组是一种特殊的对象类型
- 数组的注意点

  - 数组对应索引没有存储数据时默认为undefined

  - 访问数组不存在的索引不会报错，返回undefined
  - 数组存储空间不足时会自动扩容
  - 数组可以存储不同的数据类型
  - 数组分配的存储空间不一定是连续的(因为存储的数据类型不同)

#### 2.7.1 数组的创建方式

- 两种方式：通过[ ]创建、通过new Array创建

- 创建数组时，设置数组长度（少用）

- 代码示例

  ```javascript
  //[]字面量创建数组
  var arr = [1,2,3,4,5]
  var student = [
    {id: 111, name: kygo, age: 18},
    {id: 222, name: kygo1, age: 19},
    {id: 333, name: kygo2, age: 20}
  ] 
  //new创建数组
  var arr1 = new Array(5, 4, 3, 2, 1)
  //创建一个长度为5的空数组
  var arr2 = new Array(5)
  ```

  

#### 2.7.2 数组的基本操作

- 基本操作

  - 访问数组元素：arr[]/arr.at()

    - 区别：at可以设置负数，从数组后面往前数

  - 修改数组元素：arr[0] = "cth"

  - 删除和添加数组

    - 也可以通过索引来操作(开发很少这样做)：delete arr[1]   arr[100]=100

    ```javascript
    var arr = [1, 2, 3]
    //访问数组元素[]/at
    console.log(arr[0])  //1
    console.log(arr.at(-1))  //3
    //修改数组元素
    arr[1] = 100
    //删除/增加数组元素(这种方式不常用)
    delete arr[2]
    arr[5] = 200
    ```

- 数组的添加、删除方法一

  - push/pop

    - 从数组末端增加、删除元素

  - unshift/shift

    - 从数组首端添加、删除元素，整个数组元素向后、前移动

  - 注意

    - 添加元素可添加多个，但删除只能一个个删
    - push/pop方法比unshift/shift效率高很多
    - 增加元素方法会返回增加后数组长度，删除会返回删除的那个元素

    ```javascript
    //数组尾部增加/删除数组元素-push/pop
    var arr = [3, 2, 1]
    arr.push(0, 1, 2)  //[3, 2, 1, 0, 1, 2]
    var popitem = arr.pop()  //[3, 2, 1, 0, 1]
    console.log(popitem)  //2
    
    
    //数组首部增加/删除数组元素-unshift/shift
    var arr = [3, 2, 1]
    arr.unshift(0, 1)  //[0, 1, 3, 2, 1]
    arr.shift()  //[1, 3, 2, 1]
    ```

    

- **数组的添加、删除方法二**

  - 如果想在数组中间某个位置添加、删除元素，就必须使用splice方法了

  - 语法：arr.splice(start[, deleteCount[, item1[, item2[,...]]]])

    - 从start位置开始处理数组元素
    - deleteCount：要删除元素的个数，为0或负数表示不删除
    - item1,item2,...：需要添加的元素

  - 注意：splice方法会修改原数组

    ```javascript
    //数组增删改通用-splice
    var arr = [1, 2, 3, 4, 5]
    //在数组开头增加6,7两个元素
    arr.splice(0, 0, 6, 7)
    console.log(arr)  //[6,7,1,2,3,4,5]
    //删除索引为2,3的两个元素
    arr.splice(2, 2)
    console.log(arr)  //[6,7,3,4,5]
    //修改索引为4的元素值为100
    arr.splice(4, 1, 100)
    console.log(arr)  //[6,7,3,4,100]
    ```

    

#### 2.7.3 数组的遍历和length属性

- length属性

  - 作用：获取数组长度，当修改数组时length会自动更新
  - length是可写的
    - 如果设置大于默认lenght数值会增加数组长度
    - 设置小于默认length的数值会截断数组
  - 清空数组最简单的方法：arr.length = 0

- 数组的遍历

  - 普通for循环/for...in/for...of

    ```javascript
    //length属性
    var arr = [3, 2, 1]
    arr.length = 4
    console.log(arr)  //扩容: [3,2,1,empty]
    arr.length = 0
    console.log(arr)  //被截断: [] 
    
    //数组的遍历
    var arr = [1, 2, 3, 4]
    //1. 普通的for遍历
    for (var i = 0; i < arr.length; i++) {
      console.log(arr[i])
    }
    //2. for...in循环
    for (var index in arr){
      console.log(arr[index])
    }
    //3. for...of循环
    for (var item of arr){
      console.log(item)
    }
    ```

    

#### 2.7.4 数组slice/concat/join

- slice方法

  - 截取数组，类似于字符串的slice方法
  - arr.slice([begin[, end]])  包含begin不包含end

- concat方法

  - 创建一个新数组，其中包含其他数组和其他项
  - arr.concat(value1[, value2[,...]])  value可以是数组或其他值

- join方法

  - 将一个数组连接成一个字符串并返回
  - arr.join([separator])

- toString

  - 将数组转化成字符串
  - arr.toString === arr.join()

- 程序示例

  ```javascript
  var arr = [1, 2, 3]
  //slice方法[a, b),不会修改原数组,splice会修改原数组
  console.log(arr.slice(1, 2), arr)  //[2]
  //concat方法
  console.log(arr.concat(4, 5, [6, 7]).concat(8))  //[1,2,3...8]
  //join方法
  console.log(arr.join("-"))  //1-2-3
  ```

  

#### 2.7.5 数组中查找元素

- arr.indexOf

  - 查找某个元素的索引
  - indexOf(searchElement[, fromIndex])
  - 从formIndex找，没找到返回-1，也有lastIndexOf方法

- arr.includes

  - 判断数组是否包含某个元素
  - includes(valueToFind[, fromIndex])
  - 从formIndex找，找到返回true，否则false

- find/findIndex（ES6新增）

  - 如果使用indexOf/includes来判断对象数组类型是做不了的，这时就需要find方法了
  - 直接查找元素或元素的索引，高阶函数

- 程序示例

  ```javascript
  var arr = [1, 3, 5, 7, 9]
  //查找方式一: indexOf/lastIndexOf
  console.log(arr.indexOf(7, 1))  //3
  
  //查找方式二: includes
  console.log(arr.includes(9))
  
  var student = [
    {name: "kygo", id: 100, age: 18},
    {name: "kygo1", id: 101, age: 22},
    {name: "kygo2", id: 102, age: 60}
  ]
  //查找方式三: find/findIndex
  //findIndex和find完全相同,只是返回找到元素的索引
  var findItem = student.find(function(item, index, arr) {
    return item.age === 22
  })
  console.log(findItem)  //{name: 'kygo1', id: 101, age: 2}
  ```

  

#### 2.7.6 手动实现高阶函数

- forEach函数的实现

  ```javascript
  // 手动实现forEach高阶函数
  var arr = [2, 12, 32]
  // 版本一
  function kyForEach(fn){
    for (var i = 0; i < arr.length; i++) {
      fn(arr[i], i, arr)
    }
  }
  kyForEach(function(item, index, arr){
    console.log(item, index, arr)
  })
  // 版本二: 传入数组arr作为参数
  function kyForEach(fn, arr){
    for (var i = 0; i < arr.length; i++) {
      fn(arr[i], i, arr)
    }
  }
  kyForEach(function(item, index, arr){
    console.log(item, index, arr)
  }, arr)
  // 版本三: 将函数加到arr对象上
  // 缺点: 函数不通用,并且打印的arr种有kyForEach
  arr.kyForEach = function(fn){
    for (var i = 0; i < this.length; i++) {
      fn(arr[i], i, this)
    }
  }
  arr.kyForEach(function(item, index, arr){
    console.log(item, index, arr)
  })
  
  //终极版本: 将方法绑定到Array.prototype上
  Array.prototype.kyForEach = function(fn){
    for (var i = 0; i < this.length; i++) {
      fn(arr[i], i, this)
    }
  }
  //所有数组都可调用,和原生forEach方法一模一样
  arr.kyForEach(function(item, index, arr){
    console.log(item, index, arr)
  })
  ```

- find函数的实现

  ```javascript
  var student = [
    {name: "kygo", id: 100, age: 18},
    {name: "kygo1", id: 101, age: 22},
    {name: "kygo2", id: 102, age: 60}
  ]
  
  // 手动实现find高阶函数
  Array.prototype.kyFind = function(fn) {
    for (var i = 0; i < this.length; i++) {
      if(fn(this[i], i, this)) return this[i]
    }
  }
  var result = arr.find(function(item) {
    return item === 2
  })
  var result1 = student.find(function(item) {
    return item.id === 101
  })
  console.log(result) //2
  console.log(result1)  //{name: 'kygo1', id: 101, age:22}
  ```

  

#### 2.7.7 数组的排序和反转

- sort方法

  - 数组排序，返回排序后的新数组
  - sort([compareFunction])
  - 规则：如果compareFunction(a, b)>0，则a排在b后面，等于0顺序不变，小于0，a排b前面

- reverse方法

  - 反转数组元素并返回

- 程序示例

  ```javascript
  //数组排序
  var arr = [12, 1, 100, 34, 21, 213, 78]
  //a - b > 0 a排在b后面,所以是升序排列
  var newArr = arr.sort(function(a, b) {
    return a - b
  })
  console.log(arr === newArr)  //true
  console.log(arr)  //[1,12,21,34...]
  
  //数组反转
  arr.reverse()
  console.log(arr)  //[213,100,78,34...]
  ```

  

#### 2.7.8 其他高阶函数的使用

- arr.forEach

  - 遍历数组，让数组中的每个元素都执行一次对应方法

- arr.map

  - 创建一个新数组
  - 这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成

- arr.filter

  - 创建一个新数组
  - 新数组中只包含每个元素调用函数返回为true的元素

- arr.reduce

  - 用于计算数组中所有元素的总和
  - 对数组中的每个元素按序执行一个由您提供的 reducer 函数
  - 每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值

- 程序示例

  ```javascript
  var arr = [1, 2, 3, 4]
  //forEach方法: item等参数可按需求写
  //this绑定的是window,可以传入第二个参数作为this绑定的对象
  arr.forEach(function(item, index, arr) {
    console.log(item, this) //1 {name: "kygo"}...
  }, {name: "kygo"})
  
  //map: 数组映射
  var newArr1 = arr.map(function(item, index, arr) {
    return item * item
  })
  console.log(newArr1)  //[1, 4, 9, 16]
  
  //filter: 数组筛选
  var newArr2 = arr.filter(function(item, index, arr) {
    return item % 2 ===0  
  })
  console.log(newArr2)  //[2, 4]
  
  //reduce(fun[, initial]): 求和,initial表示初始值
  //pre-上次求和的值
  //item-当前元素  index-当前索引
  //注意: 不写初始值,默认初始值是第一个元素,index从1开始(第二个元素)累加
  var result = arr.reduce(function(pre, item, index) {
    return pre + item
  }, 100)
  console.log(result) //10
  
  //综合练习: 过滤所有偶数,映射所有偶数的平方,并且计算他们的和
  var arr1 = [2, 11, 32, 47, 110, 231]
  //以下为链式写法
  var res = arr1.filter(function(item) {
    return item % 2 === 0 
  }).map(function(item) {
    return item * item
  }).reduce(function(preValue, item) {
    return preValue + item
  })
  console.log(res)
  ```

    

## 3. JS代码规范和浏览器调试技巧

### 3.1 代码规范

```javascript
function pow(x, n) {  //1. 多个参数,后面留空格 开花括号{不单独起一行且前面留空
  var result = 1  //2. 操作符左右两边留空格
  for (var i = 0; i < n; i++) {  //3. 循环语句;后面留空格
    result *= x  //4. 代码缩进两个空格
  }
  return result;  //5. 分号可加可不加,但是在必要时必须加,如立即执行函数前面
}

var x = prompt("请输入x")  //6. 不同功能代码块之间空行
var n = prompt("请输入n")

if (n > 0) {  //7. for/if/while后面跟空格
  console.log(pow(x, n))  //8. 函数多个参数传参,后面跟空格
} else {  //9. "} else {" 在同一行显示
  console.log(`pow函数不支持小于0的数,你输入的n小于0,
  请输入大于等于0的数`)  //10. 一行不能太长
}
```

### 3.2 浏览器调试技巧

- debug的认识
  - 终极技巧：debug
  - 当代码出问题的时候，可以通过debug找出bug
  - 浏览器实现debug就是打断点

- 浏览器的debug

  - debug过程解析

    ![](../../public/img/浏览器调试技巧一.png)

  - 右侧工具栏的作用

    ![](../../public/img/浏览器调试技巧二.png)

  - 右下侧工具栏

    ![](../../public/img/浏览器调试技巧三.png)

- 代码中的debugger

  - 代码中写上debugger和浏览器中打断点效果是一样的，程序都会停在那个地方

    ```javascript
    console.log("循环前")
    var result = 0
    
    debugger  //debugger标识符就是在代码中打断点的方式
    
    function foo(){
      console.log("foo执行啦")
    }
    foo()
    ```

    

## 4. DOM

### 4.1 初识DOM

#### 4.1.1 认识DOM和BOM

- 对象解析

  - window
    - 全局对象，代表浏览器打开的一个窗口
    - 每个窗口都是一个window对象 

  - document
    - window的一个属性，这个属性是一个对象
    - 代表当前窗口的整个网页，可以操作整个网页的所有内容

- 作用
  - 前面学习的ECMAScript是JS的基本语法部分，不涉及对网页和浏览器的操作
  - DOM和BOM是浏览器提供给开发者去操作页面和浏览器的API(接口/方法/属性)
- 概念
  - DOM
    - 文档对象模型（Document Object Model），简称DOM
    - 将页面所有的内容表示成可以修改的对象
  - BOM
    - 浏览器对象模型（Browser Object Model）
    - 用于处理文档之外的所有其他内容的对象，如：navigator、location、history
- 深入理解DOM
  - 浏览器考虑到我们会通过js操作页面的元素，所以将所有的元素抽象成了对象
  - 整个文档被抽象到Document对象中 （如：通过Document.head/body就可拿到head/body元素）
    - 如：document.body.style.backgroundColor = "red" 就会让整个页面背景变成红色
  - 学习DOM就是学习通过document对象操作网页内容



#### 4.1.2 DOM Tree

- html结构中最终会形成一个树结构
- 在抽象成DOM对象的时候也会形成一个树结构-DOM Tree

#### 4.1.3 DOM的继承关系

- DOM相当于是JavaScript和HTML/CSS之间沟通的桥梁

  - 通过浏览器提供的DOM API，可以对元素及其内容做任何操作

- DOM的继承关系图

  ![](../../public/img/DOM继承关系图.png)



#### 4.1.5 document对象

- Document节点表示整个载入的网页，它的实例是全局的document对象

  - 对DOM的所有操作都是从document对象开始的
  - 它是DOM的入口点，可以从document开始去访问任何节点元素

- 对于最顶层的html、head、body元素，我们可以直接在document对象中获取到

  - html元素 - document.documentElement

  - body/head元素 - document.body/head

  - 文档声明 - document.doctype

    ```javascript
    var htmlEl = document.documentElement
    var headEl = document.head
    var bodyEl = document.body
    var docEl = document.doctype
    console.log(htmlEl, headEl, bodyEl, docEl)  //html/head/body/docType
    ```

    

### 4.2 导航获取元素/节点

#### 4.2.1 节点之间的导航

- 什么是节点之间的导航

  - 当获取到一个节点后，根据这个节点获取其他的结点
  - 注意：结点包括元素、注释、空行、文本等都属于节点

- 节点之间存在的关系

  - 父节点：parentNode
  - 前兄弟节点：previousSibling
  - 后兄弟节点：nextSibing
  - 子节点：childNodes
  - 第一个子节点：firstChild
  - 最后一个子节点：lastChild

- 代码示例

  ```html
  <!-- 我是注释 -->
    嘿嘿嘿
  <div class="box">
    <p>我是段落哈哈哈哈</p>
  </div>
  <script>
    var bodyEl = document.body
    var childNodes = bodyEl.childNodes  //获取所有子节点
    console.log(childNodes)  //[text, comment, text, div.box, text, script]
    var boxEl = childNodes[2].nextSibling
    var pEl = boxEl.firstChild
    var boxEl1 = pEl.parentNode
    console.log(boxEl, boxEl1, pEl)  //div.box div.box #text
  </script>
  ```

  

#### 4.2.2 元素之间的导航

- 什么是元素之间的导航

  - 同理，通过一个元素获取到其他元素

- 元素之间存在的关系

  - 父元素：parentElement
  - 前兄弟元素：previousElementSibling
  - 后兄弟元素：nextElementSibing
  - 子元素：children
  - 第一个子元素：firstElementChild
  - 最后一个子元素：lastElementChild

- 代码示例

  ```html
  哈哈哈哈
  <h1>我是标题</h1>
  <div class="box">
    <p>我是段落</p>
  </div>
  
  <script>
    var bodyEl = document.body
    childEls = bodyEl.children  //获取body中所有子元素
    console.log(childEls)  //[h1, div.box, script]
  
    var scriptEl = bodyEl.lastElementChild
    var boxEl = scriptEl.previousElementSibling
    var boxEl1 = boxEl.lastElementChild.parentElement
    console.log(scriptEl, boxEl, boxEl)  //<script> <div> <div>
  </script>
  ```

  

#### 4.2.3 table元素之间的导航

- table元素支持以下属性（除了上面给出的）

  - table.rows    tr元素集合
  - table.caption/tHead/tBodies/tFoot    

- thead/tbody/tfoot元素提供了rows属性

  - tbody.rows

- tr元素

  - tr.cells    给定的tr中td和th的集合
  - tr.sectionRowIndex/tr.rowIndex    tr在thead/tbody/tfoot中的位置、整个表格中的位置

- td和th元素

  - td.cellIndex    封闭的tr中单元格的编号

- 代码示例

  ```javascript
  var tableEl = document.body.children[0] //as HTMLTableElement
  var rows = tableEl.rows  //获取所有tr
  var theadEl = tableEl.tHead  //获取tHead
  var tbodyEl = tableEl.tBody  //获取tBody
  var thRowEl = theadEl.rows  //通过tHead获取其中的row
  var thsEl = rows[0].cells  //获取th
  var rowIndex = rows[2].rowIndex  //获取row是第几个row
  var tdIndex = rows[2].cells[1].cellIndex  //获取td是第几个
  //<tbale> [tr,tr,tr] true [th,th,th] 2 1
  console.log(tableEl, rows, thRowEl[0] === rows[0], thsEl, rowIndex, tdIndex)  
  ```

  

#### 4.2.4 form元素之间的导航

- form元素可通过ducument来获取：document.forms

- form元素中的内容可通过elements来获取：form.elements

- 可以通过表单子元素的name属性来获取：elements.password

- 代码示例

  ```html
  <form action="">
    <input type="text" name="id">
    <input type="password" name="password">
  </form>
  <script>
    var formEl = document.forms[0]
    var formAllEl = formEl.elements
    var idInputEl = formAllEl.id
    var passwordEl = formAllEl.password
    //result: [input, input, id:input, password:input] 
    //<input name="id"></input> <input name="password"></input>
    console.log(formAllEl, idInputEl, passwordEl)
  </script>
  ```

  

### 4.3 获取任意元素

- DOM导航属性只适用于元素之间相邻或相近时（层级太多写起来不方便）

- DOM为我们提供了以下可以任意获取元素的方法

  - querySelector/querySeletorAll
    - 通过选择器查找元素，开发最常用
  - getElementById/getElementsByClassName
    - 通过id/class查找元素，有时候用（适配低版本浏览器）
  - getElementsByName/getElementsByTagName
    - 通过name属性、标签名获取（用得很少，了解）

- 是否能在元素上使用，是否实时（了解）

  - query、ByClass、TagName可以在元素上使用
    - 可以通过元素.的方法调用，在其子元素中查询
  - ByName、ByTagName、ByClassName支持实时更新
    - 元素属性先输出，再修改，也会输出最新的

- 代码示例

  ```html
  <div class="box" id="box">我是box</div>
  <input type="text" name="password">
  
  <script>
    var boxEl = document.querySelector(".box")  //找到第一个满足条件的就返回
    var boxEl1 = document.querySelectorAll(".box")[0]
  
    var boxEl2 = document.getElementsByClassName("box")[0]
    var boxEl3 = document.getElementById("box")
  
    var boxEl4 = document.getElementsByTagName("div")[0]
    var inputEl = document.getElementsByName("password")
    //以下结果都是true
    console.log(boxEl === boxEl1)
    console.log(boxEl1 === boxEl2)
    console.log(boxEl2 === boxEl3)
    console.log(boxEl3 ===boxEl4)
    console.log(inputEl)
  </script>
  ```

  

### 4.4 node节点常见属性

- 主要讨论节点共有的属性

- nodeType属性

  - 作用：获取节点的类型，返回的是数值类型
  - 常见结点类型
    - Node.ELEMENT_NODE  1  元素节点
    - Node.TEXT_NODE  3  文本节点
    - Node.COMMENT_NODE  8  注释节点
    - Node.DOCUMENT_NODE  9  文档节点
    - Node.DOCUMENT_TYPE_NODE  10  文档类型节点

- nodeName、tagName属性

  - 作用：用于获取node节点的名字，元素的标签名
  - 不同
    - tagName只适用于Element元素节点
    - nodeName使用于任意节点

- innerHTML、textContent属性

  - innerHTML属性
    - 可以获取元素中的所有内容，包括HTML，以字符串形式返回
    - 可以设置元素的内容（如果有HTML会解析）
  - textContent属性
    - 仅仅获取元素中的文本内容（设置内容时不会解析HTML）
  - outerHTML属性
    - 包含了元素本身的完整HTML

- data/nodeValue

  - 用于获取非元素节点的文本内容（如：注释、文本）

- 其他属性

  - hidden属性：全局属性，设置元素的显示隐藏
  - value（表单元素）、href（a）、id（所有元素的attribute值）

- 代码示例

  ```html
  <!-- 注释 -->
  <div class="box">
    我是box
    <p>我是段落</p>
  </div>
  <button class="btn">显示/隐藏</button>
  
  <script>
    var bodyEl = document.body
    //节点类型nodeType
    var allNodeEl = bodyEl.childNodes
    //3#text 8<!--注释--> 3#text 1<div> 3#text 1<script>
    for(var item of allNodeEl){
      console.log(item.nodeType, item)
    }
  
    //nodeName/tagName
    console.log(bodyEl.childNodes[0].nodeName)  //#text
    console.log(bodyEl.childNodes[0].tagName)  //undefined
  
    console.log(bodyEl.childNodes[3].nodeName)  //DIV
    console.log(bodyEl.childNodes[3].tagName)  //DIV
  
    //innerHTML/textContent/outerHTML
    var boxEl = document.querySelector(".box")
    console.log(boxEl.innerHTML)  //我是box<p>我是段落<p>
    //<div class="box">我是box<p>我是段落<p><div>
    console.log(boxEl.outerHTML)  
    console.log(boxEl.textContent)  //我是box 我是段落
    boxEl.innerHTML="<h1>我是box中的h1</h1>"
  
  
    //data/nodeValue
    console.log(allNodeEl[1].nodeValue)  //注释
    console.log(allNodeEl[1].data)  //注释
  
    //显示和隐藏box
    var btnEl = document.querySelector(".btn")
    btnEl.onclick = function(){
      boxEl.hidden = !boxEl.hidden 
    }
  </script>
  ```

  

### 4.5 元素

#### 4.5.0 元素属性和特征的基本认识

- 一个元素除了有开始标签、结束标签、内容，还有很多的属性（attribute）
- 浏览器在解析HTML元素时，会将对应的attribute也创建出来放到元素上
  - 如元素的id、class就是全局的attribute，对象上有对应的id、class属性
  - href属性是针对于a元素的，value和type是针对于input元素的
- 属性和特征的区分
  - 通常我们将html元素上加的属性叫做特征-attribute
  - 在元素对象中封装的属性叫做-property

#### 4.5.1 元素的特征attribute

- 分类

  - 标准attribute
    - 原本存在的浏览器提供的元素attribute，如：id、class、style
  - 非标准attribute
    - 自定义的attribute，如age、height

- attribute的操作

  - elem.hasAttribute(name)  检查特征是否存在
  - elem.getAttribute(name)  获取特征值
  - elem.setAttribute(name, value)  设置特征值
  - elem.removeAttribute(name)  移除特征
  - attributes  元素的所有属性的集合

- attribute特征

  - 名字的大小写不敏感（id和ID获取是一样的）
  - 获取到的值总是字符串类型（如checked获取到的是空字符串）

- 代码示例

  ```html
  <!-- class就是标准attribute, height/name就是非标准attribute -->
  <div class="box" height="1.88" name="kygo">
    我是box
  </div>
  <input type="radio" checked>
  
  <script>
    //所有attribute都支持的操作
    var boxEl = document.querySelector(".box")
    var hasAttr = boxEl.hasAttribute("class")
    var attrName = boxEl.getAttribute("name")
    var attrs = boxEl.attributes
    //class box   height 1.88   name kygo
    for(var attr of attrs){
      console.log(attr.name, attr.value)
    }
    boxEl.removeAttribute("height")
    //有就修改,没有就增加
    boxEl.setAttribute("height1", 1.98) 
    //Result: true kygo  {0: class, 1: name, 2: height1...}
    console.log(hasAttr, attrName, attrs) 
    //输出空字符串，getAttribute获取到的都是字符串类型
    console.log(document.querySelector("input").getAttribute("checked"))
  </script>
  ```

  

#### 4.5.2 元素的属性property

- 对于标准的attribute，会在DOM对象上创建对应的property属性

- attribute和property相互作用

  - 改变property，通过attribute获取到的值也会改变
  - 通过attribute修改，property的值也会改变

- 推荐使用property来设置、获取元素的attribute

  - 因为通过property获取的值是有类型的，而attribute获取的都是字符串

- 自定义属性data的获取

  - html中可以通过data-*自定义属性，这些attribute可以通过dataset属性获取到

- 代码示例

  ```html
  <div class="box" title="标题" name="kygo" data-age="18">
    我是box
  </div>
  <input type="radio" checked>
  
  <script>
    var boxEl = document.querySelector(".box")
    var inputEl = document.querySelector("input")
    boxEl.className = "box1"
    boxEl.setAttribute("class", "box2")
    //通过property获取属性(只能获取非自定义属性)
    console.log(boxEl.name)  //undefined
    console.log(boxEl.title)  //标题
    console.log(boxEl.className)  //  box2
    //获取的属性值有类型  Result: true 'boolean' radio'
    console.log(inputEl.checked, typeof inputEl.checked, inputEl.type) 
    //自定义属性的获取
    console.log(boxEl.dataset.age)  //18
  </script>
  ```

  

#### 4.5.3 元素的class和style

- JavaScript动态修改样式

  - 方法一：在css中写好样式，动态添加class
  - 方法二：动态修改style属性
  - 方法的选择
    - 大多数情况下，更推荐使用动态的class
    - 某些情况不能动态修改class（如精准修改某个css属性值），就可以修改style属性

- 元素的className和classList

  - 元素的className
    - 元素的class attribute，对应的property叫做className，而不是class（class是关键字）
    - 可以对className赋值，它会替换整个class中的字符串
  - 元素的classList
    - 当需要添加或移除单个的class，可以使用classList属性
    - elem.classList是特殊的对象
      - elem.classList.add(class)  添加一个类
      - elem.classList.remove(class)  移除类
      - elem.classList.toggle(class)  不存在添加，存在移除类
      - elem.classList.contains(class)  检查类，返回true/false
    - classList是可迭代对象，可以通过for...of遍历

- 元素的style属性

  - 单独修改某一个css属性，可以通过style来操作
  - 多个样式的写法，需要使用cssText属性（不推荐）
  - 注意
    - 对于多词属性，使用驼峰：boxEl.style.backgroundColor = "red"
    - 如果将值设置为空字符串，会使用默认的css样式（如：boxEl.style.display=""）

- 元素style的读取-getComputedStyle

  - 对于内联样式，可以通过style.*的方式读取到
  - 对于style标签、css文件中的样式是读取不到的
    - 可以通过getComputedStyle的全局函数来读取：getComputedStyle("boxEl").width

- 代码示例

  ```html
  <style>
    .box{
      width: 300px;
      height: 300px;
    }
    .active{
      font-size: 30px;
      background: purple;
      color: #fff;
    }
    .active1{
      font-size: 10px;
    }
  </style>
  <body>
  <div class="box">我是box</div>
  
  
  <script>
    var boxEl = document.querySelector(".box")
    //通过style属性来修改样式
    boxEl.style.color = "red"
    boxEl.style.backgroundColor = "pink"
    //style的读取
    console.log(boxEl.style.color)  //red
    //如果不是内联样式必须这样读取才行
    console.log(getComputedStyle(boxEl).width)  //300px
  
  
    //通过动态添加className来修改样式(会覆盖所有之前的class)
    boxEl.className = "active"
    //通过classList来修改样式
    boxEl.classList.remove("active")
    boxEl.classList.add("active1")
    console.log(boxEl.classList.contains("active"))  //false
  
  </script>
  ```

  

#### 4.5.4 元素的常见操作

- 创建元素

  - 以前写入元素的方式：document.write/innerHTML（不推荐）
  - 创建元素语法
    - document.createElement(tag)

- 插入元素

  - node.append(...nodes or strings)  node末尾插入节点或字符串
  - node.prepend  node开头插入
  - node.before      node前面插入
  - node.after         node后面插入
  - node.replaceWith  将node替换成指定节点或字符串

- 移除元素和克隆元素

  - 移除
    - node.remove  node移除自己
  - 克隆
    - 语法：node.cloneNode([true])  
    - 解释：传入true表示深度克隆（包含子元素），返回克隆出来的node

- 旧的元素操作方法（了解-基本不用了）

  - parentEl.appendChild(node)
  - parentEl.insertBefore(node,nextSibling)
  - paretEl.replaceChild(node, oldChild)
  - parentEl.removeChild(node)

- 代码示例

  ```html
  <p>我是段落1</p>
  <div class="box">我是box</div>
  <p>我是段落2</p>
  
  <script>
    //以前的做法(不推荐)
    document.write("<h1>我是write写入的标题<h1>")
    //新增元素
    var h1El = document.createElement("h1")
    var h2El = document.createElement("h2")
    h1El.textContent = "我是插入的标题h1"
    h2El.textContent = "我是插入的标题h2"
    //插入元素
    var boxEl = document.querySelector(".box")
    // boxEl.append(h2El)
    // boxEl.prepend(h1El)
    // boxEl.before(h1El)
    // boxEl.after(h1El)
    // boxEl.replaceWith(h2El)
  
    //移除元素
    // boxEl.remove()
    //克隆元素
    var boxEl1 = boxEl.cloneNode(true)
    boxEl.append(boxEl1)
  </script>
  ```

  

#### 4.5.5 元素的大小和滚动

- client相关（元素内部）

  - clientWidth/clientHeight
    - contentWith/Height+padding (不包含滚动条)
  - clientTop/clientLeft
    - border-top的宽度、border-left的宽度

- offset相关

  - offsetWidth/offsetHeight：元素完整的宽度/高度
  - offsetLeft/offsetHeight：距离第一个定位父元素的X/Y

- scroll相关

  - scrollHeight：整个可滚动的区域高度
  - scrollTop：滚动部分的高度

- 代码示例

  ```html
  <style>
    .box{
      width: 200px;
      height: 200px;
      padding: 10px;
      overflow: auto;
      background-color: pink;
      border: 10px solid red;
    }
  </style>
    
  <div class="box">
    <br><br><br><br><br><br><br><br><br><br><br><br>
    <br><br><br><br><br><br><br><br><br><br><br><br>
    123
  </div>
  <script>
    var boxEl = document.querySelector(".box")
    //原来获取样式的方法,通过getCom,局限性很强
    console.log(getComputedStyle(boxEl).width)
    
    //滚动条占据了宽度,所以元素的宽度只有185+10*2
    console.log(boxEl.clientHeight, boxEl.clientWidth)//220 205
    console.log(boxEl.clientTop, boxEl.clientLeft)// 10 10
    //元素整体所占宽高:加上border
    console.log(boxEl.offsetWidth, boxEl.offsetHeight)//240 240
    //元素距离父元素的X/Y,这里是自带的外边距
    console.log(boxEl.offsetLeft, boxEl.offsetTop)//8 8
    //可滚动的高度/滚动了多少高度
    console.log(boxEl.scrollHeight, boxEl.scrollTop)//583 0
    //监听滚动事件,打印滚动的距离
    boxEl.addEventListener("scroll", function() {
      console.log(boxEl.scrollTop)
    })
  </script>
  ```

  

#### 4.5.6 window的大小和滚动

- window的宽高

  - innerWidth/innerHeight：获取window窗口的宽度和高度（包含滚动条）
  - outerWidth/outerHeight：获取window窗口的整个宽高（包括调试工具、工具栏）
  - documentElement.clientHeight/documentElement.clientWidth  html/网页的宽高

- window的滚动位置

  - scrollX：X轴滚动的位置（别名pageXOffset）
  - scrollY：Y轴滚动的位置（别名pageYOffset）

- 滚动方法

  - scrollBy(x, y)：将页面滚动至相对当前位置的x,y的位置
  - scrollTo(pageX, pageY)：滚动至绝对坐标

- 代码示例

  ```html
  <br><br><br><br><br><br><br><br><br><br><br><br>
  <button class="btn">scrollTo</button>
  <button class="btn1">scrollBy</button>
  <br><br><br><br><br><br><br><br><br><br><br><br>
  <br><br><br><br><br><br><br><br><br><br><br><br>
  <br><br><br><br><br><br><br><br><br><br><br><br>
  <button class="toTop">回到顶部</button>
  <script>
    //681 1319 整个页面的宽高(不包含工具栏)
    console.log(window.innerHeight, window.innerWidth)
    //760 1319 整个浏览器宽高(包含工具栏)
    console.log(window.outerHeight, window.outerWidth)
    //681 1304  整个页面宽高(不包含滚动条)
    console.log(document.documentElement.clientHeight, document.documentElement.clientWidth)
    //监听滚动事件,打印滚动位置
    window.addEventListener("scroll", function() {
      console.log(window.scrollX, window.screenY)
    })
    //滚动到绝对位置
    document.querySelector(".btn").addEventListener("click", function() {
      window.scrollTo(100, 100)
    })
    //以当前滚动位置为参考点
    document.querySelector(".btn1").addEventListener("click", function() {
      window.scrollBy(100, 100)
    })
    
    //点击按钮回到顶部案例
    var btnTop = document.querySelector(".toTop")
    btnTop.addEventListener("click", function() {
      window.scrollTo(0, 0)
    })
    btnTop.hidden = true
    //如果滚动距离较近,隐藏按钮
    window.addEventListener("scroll", function() {
      if(window.scrollY > 800){
        // btnTop.style.display = "block"
        btnTop.hidden = false
      }else{
        // btnTop.style.display = "none"
        btnTop.hidden = true
      }
    })
  </script>
  ```

  

### 4.6 事件

#### 4.6.1 认识事件处理

- 什么是事件

  - Web页面和用户进行交互的过程中执行的某种动作

- 事件监听的三种方法

  - DOM属性监听

  - 在script中直接监听

  - 通过EventTarget中的addEventListener来监听

    ```html
    <!-- 事件处理方式一: HTML属性内 -->
    <button onclick="console.log('hello event')">btn</button>
    <button class="btn2">btn2</button>
    <button class="btn3">btn3</button>
    <script>
      //事件处理方式二: onclick属性赋值函数(添加多次后面会覆盖前面的)
      document.querySelector(".btn2").onclick = function() {
        console.log("hello event")
      }
      //方式三: addEventListener方法（添加多次不会覆盖）
      document.querySelector(".btn3").addEventListener("click", function() {
        console.log("hello event")
      })
    </script>
    ```

    

#### 4.6.2 事件冒泡捕获

- 事件流

  - 当一个元素被点击时，其实点击的还有它的父元素
  - 而这种一层层把点击传递到父元素的动作就叫事件流

- 事件冒泡和事件捕获

  - 传递方向
    - 事件冒泡：默认情况下事件是从最内层(发生点击的那层)依次向外传递的
    - 事件捕获：另一种监听事件的方式，从外层到内层
  - 为什么会产生两种不同的处理流
    - 在早期IE和Netscap公司采用完全相反的事件流对事件进行传递
    - IE采用事件冒泡，Netscape采用事件捕获
  - 如何去监听事件冒泡/捕获的过程
    - 默认情况下就是事件冒泡
    - 事件捕获需要传递第二个参数true才能监听

- 事件捕获和冒泡的过程

  - 如果我们同时监听事件捕获和冒泡，会按照以下顺序执行
    - 捕获阶段：事件从window向内层走进元素
    - 目标阶段：事件到达目标元素
    - 冒泡阶段：事件从元素上开始冒泡
  - 获取当前阶段：事件对象event.eventPhase
  - 开发通常使用事件冒泡，事件捕获了解即可

- 代码示例

  ```html
  <div class="box"><span></span></div>
  
  <script>
    var boxEl = document.querySelector(".box")
    var spanEl = document.querySelector("span")
    //点击span会打印: span事件执行 box事件执行了
    //默认只执行冒泡(没有监听捕获的情况下)
    spanEl.onclick = function(){
      console.log("span事件执行了!")
    }
    boxEl.onclick = function(){
      console.log("box事件执行了!")
    }
    //添加以下捕获监听后,打印如下
    //捕获box => 捕获span => span事件执行 => box事件执行
    spanEl.addEventListener("click", function() {
      console.log("我是捕获的span")
    }, true)
    boxEl.addEventListener("click", function() {
      console.log("我是捕获的box")
    }, true)
  </script>
  ```

  

#### 4.6.3 事件对象event

- 什么是事件对象

  - 事件发生时会传递一个对象，它封装了事件的相关信息（如：事件类型、点击元素、点击位置...）

- 事件对象的获取

  - 在传入的回调函数参数中拿到event对象

- event常见属性和方法

  - 常见属性
    - type eventPhase  事件类型/事件所处阶段
    - target currentTarget  当前事件发生的元素/当前事件处理元素 （常用）
    - offsetX offsetY  事件发生在元素内的位置
    - clientX clientY  事件发生在客户端内的位置(没有滚动条时和page一样)
    - pageX pageY    事件发生相对于document的位置
    - screenX screenY  事件发生相对于屏幕位置
  - 常见方法
    - preventDefault  取消事件的默认行为
    - stopPropagation  阻止事件的传递（冒泡和捕获都可以阻止）

- 事件处理中的this

  - this指向当前发生的元素，和event.currentTarget完全一致

- 代码示例

  ```html
  <div class="box"><span></span></div>
  <a href="http://www.baidu.com">百度一下</a>
  
  <script>
    var boxEl = document.querySelector(".box")
    var spanEl = document.querySelector("span")
  
    spanEl.addEventListener("click", function(event) {
      //一些位置信息
      console.log(event.clientX, event.clientY)
      console.log(event.offsetX, event.offsetY)
      console.log(event.pageX, event.pageY)
      console.log(event.screenX, event.screenY)
        
      console.log(event.type, event.eventPhase)  //click 2
      //<span></span>  span></span>
      console.log(event.target, event.currentTarget)
      //阻止冒泡,加了这行代码,box就不会冒泡了
      event.stopPropagation()
    })
    boxEl.onclick = function(event) {
      console.log(event.eventPhase)  //冒泡触发 3  自己点击触发 2
      //点击span: <span></span>  <div></div>
      //点击div: <div></div>  <div></div>
      console.log(event.target, event.currentTarget)
    }
  
    //阻止a链接的默认跳转行为
    document.querySelector("a").addEventListener("click", function(event) {
      event.preventDefault()
      //this指向currentTarget
      this.style.color = "green"
      console.log(event.currentTarget === this)  //true
    })
  </script>
  ```

  

#### 4.6.4 EventTarget使用

- 所有节点、元素都继承自EventTarget，包括Window

- EventTarget作用

  - 是一个DOM接口，用于添加、删除、派发Event事件

- 常见方法

  - addEventListener  注册某个类型的事件处理函数
  - removeEventListener  移除某个类型的事件处理函数
  - dispatchEvent  派发某个事件类型到EventTarget上

- 代码示例

  ```html
  <button>click</button>
  <script>
    var btnEl = document.querySelector("button")
    function fun(){
      console.log("点击了")
    } 
    //添加事件监听
    btnEl.addEventListener("click", fun)
    //删除事件监听
    btnEl.removeEventListener("click", fun)
  
    window.addEventListener("kygo", function() {
      console.log("事件执行啦")
    })
    //给window派发事件
    window.dispatchEvent(new Event("kygo"))
  </script>
  ```

  

#### 4.6.5 事件委托模式

- 事件委托的实现原理
  - 事件冒泡
  - 当子元素被点击时，父元素可以通过冒泡监听到子元素的点击
  - 并且可以通过event.target获取到点击的元素
- 应用举例
  - 一个ul中有多个li，点击某个li变红色
  - 方案
    - 一：监听每一个li的点击，做出相应变化（不推荐）
    - 二：在ul中监听li的点击，通过taget拿到点击的li处进行理（更加高效，不需遍历）

- 事件委托的标记
  - 事件委托可能会需要对具体的子元素进行区分，这时可以通过使用date-*来标记
  - 通过event.target.dataset.*来获取具体某个子元素，如点击了哪个按钮等

- 代码示例

  ```html
  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
  </ul>
  <script>
    var ulEl = document.querySelector("ul")
    var liEls = document.querySelectorAll("li")
    // 循环实现添加
    // for(var item of liEls) {
    //   item.onclick = function() {
    //     this.classList.add("active")
    //   }
    // }
  
    var beforeClickEl = null
    //事件委托实现
    ulEl.addEventListener("click", function(event) {
        
      //点击取消前一次变色的
      //方案一: 循环遍历
      // for(var item of liEls){
      //     if(item.classList.contains("active")){
      //       item.classList.remove("active")
      //     }
      // }
      // 方案二: 查找有active的
      // var activeEl = document.querySelector(".active")
      // activeEl && activeEl.classList.remove("active")
        
      //方案三: 变量记录上次点击的li
      beforeClickEl && beforeClickEl.classList.remove("active")
      event.target.classList.add("active")
  	  //记录当次变色的li
      beforeClickEl = event.target
      
      //通过dataset找到具体某个子元素
      if(event.target.dataset.name === "kygo") {
        console.log("点击了kygo")
      }
    })
  </script>
  ```

  

#### 4.6.6 常见的事件

- 常见的鼠标事件

  - 不仅仅是鼠标，也包括模拟鼠标的设备（如手机、平板）
  - click/contextmenu/dblclick
    - 点击/点击右键/双击
  - mousedown/mouseup
    - 鼠标按钮按下/抬起
  - mouseover/mouseout
    - 鼠标移到元素上/移出（支持冒泡）
  - mouseenter/mouseleave
    - 鼠标移到元素上/移出（不支持冒泡）
  - mousemove  鼠标移动

- mouseover和mouseenter区别解析

  - mouseenter和mouseleave

    - 不支持冒泡
    - 进入子元素依然属于该元素内，没有任何反应

  - mouseover和mouseout

    - 支持冒泡
    - 进入子元素时：
      - 先调用父元素的mouseout => 再调用子元素的mouseover 
      - =>因为冒泡mouseover传递到父元素

  - **应用**

    - mouseover/out可用于事件委托，而mouseenter不行(事件委托前提是支持冒泡)

    ```html
    <button class="btn">点击</button>
    <div class="box"><span></span></div>
    <script>
      //鼠标右击阻止默认事件示例
      document.documentElement.addEventListener("contextmenu", function(event) {
        event.preventDefault()
      })
    
      //mouseover和mouseout
      var boxEl = document.querySelector(".box")
      var spanEl = document.querySelector("span")
      //鼠标从box进入span: box over => box out => span over => box over
      //鼠标从span出来到box,再出box外: span out => box out => box over => box out
      // boxEl.addEventListener("mouseover", function() {
      //   console.log("box over")
      // })
      // boxEl.addEventListener("mouseout", function() {
      //   console.log("box out")
      // })
      // spanEl.addEventListener("mouseover", function() {
      //   console.log("span over")
      // })
      // spanEl.addEventListener("mouseout", function() {
      //   console.log("span out")
      // })
      
      //鼠标进入box到pan再从span出来到box,最后出box
      //box enter => span enter => span leave => box leave
      boxEl.addEventListener("mouseenter", function() {
        console.log("box enter")
      })
      boxEl.addEventListener("mouseleave", function() {
        console.log("box leave")
      })
      spanEl.addEventListener("mouseleave", function() {
        console.log("span enter")
      })
      spanEl.addEventListener("mouseleave", function() {
        console.log("span leave")
      })
    </script>
    ```

    

- 键盘事件

  - 常见键盘事件

    - onkeydown  某个键盘按键被按下
    - onkeypress  某个键盘按键被按下
    - onkeyup 某个键盘按键被松开

  - 事件执行顺序

    - down => press => up

  - key和value

    - 作用：区分按下的键
    - event.key：字符("A"...),非字符和code一样
    - event.code：按键代码（"KeyA"）

    ```html
    <input type="text" class="search">
    <script>
      var inputEl = document.querySelector(".search") 
      //当在input按下某个键立即松开: key down => key press => key up
      //按下某个键不立即松开: key down => key press =>keydown keypress... =>key up
      inputEl.addEventListener("keydown", function() {
        console.log("key down!")
      })
      inputEl.addEventListener("keyup", function() {
        console.log("key up!")
      })
      inputEl.addEventListener("keypress", function() {
        console.log("key press!")
      })
    
      //案列1: 点击enter键进行搜索
      inputEl.addEventListener("keyup", function(event) {
        //Enter Enter
        console.log(event.code, event.key)
        if (event.code === "Enter") {
          console.log("开始搜索")
        }
      })
    
      //案列2: 点击s键光标聚焦到搜索框
      document.documentElement.addEventListener("keyup", function(event) {
        //KeyS s  不用记,先打印看看值再使用
        console.log(event.code, event.key)
        if (event.code === "KeyS") {
          inputEl.focus()
        }
      })
    </script>
    ```

    

- 常见表单事件

  - onchange  表单元素内容改变时触发(当光标离开且内容改变才会触发)

  - oninput  元素获取用户输入时触发

  - onfocus/onblur  获取/失去焦点触发

  - onreset/onsubmit  表单重置/提交时触发（针对于表单form元素）

    ```html
    <form action="/123">
      <input type="text">
      <button type="submit">submit</button>
    </form>
    <script>
      var inputEl = document.querySelector("input")
      //光标定到input,在input中输入到光标离开input
      //focus => input input... => change => blur
      inputEl.addEventListener("input", function() {
        console.log("input事件执行了")
      })
      inputEl.addEventListener("change", function() {
        console.log("change事件执行了")
      })
      inputEl.addEventListener("focus", function() {
        console.log("focus事件执行了")
      })
      inputEl.addEventListener("blur", function() {
        console.log("blur事件执行了")
      })
      //阻止submit按钮默认事件提交
      //方式一: 使用submit按钮的click阻止
      // var submitEl = document.querySelector("button")
      // submitEl.addEventListener("click", function(event) {
      //   event.preventDefault()
      // })
      //方式二: 使用form表单的submit事件阻止
      var formEl = document.querySelector("form")
      formEl.addEventListener("submit", function(event) {
        event.preventDefault()
      })
    </script>
    ```

    

- 文档加载事件

  - DOMContentLoaded

    - 浏览器已经完全加载HTML并创建DOM树，但是img和link样式表等外部资源可能还没有完全加载

  - load  

    - HTML和所有外部资源都已加载完成

    ```html
    <script>
      //如果将js放到html前面就会拿不到元素
      window.addEventListener("DOMContentLoaded", function() {
        var imgEl = document.querySelector("img")
        //0 0 会出现获取不到图片大小的情况,因为DOMContentLoaded事件不会等待外部资源加载
        console.log(imgEl.offsetWidth, imgEl.offsetHeight)
      })
      //这时可以使用load
      window.addEventListener("load", function() {
        var imgEl = document.querySelector("img")
        //860 574
        console.log(imgEl.offsetWidth, imgEl.offsetHeight)
      })
      
      //resize-文档视图大小调整时触发
      window.onresize = function() {
        console.log("屏幕尺寸改变了!")
      }
      
    </script>
    
    <div class="box">box</div>
    <img src="./../../img/R-C.jpeg" alt="">
    ```

    

- 事件类型文档：https://developer.mozilla.org/zh-CN/docs/Web/Events



### 4.7 定时器

- 定时器作用：推迟/重复执行一个函数的执行，定时调用
- 两种方法
  - setTimeout
    - 将函数推迟一段时间间隔再执行
    - clearTimeout-取消定时器
  - setInterval
    - 以相同事件间隔重复运行一个函数
    - clearInterval-取消定时器
  - 虽然是window对象上的方法，但是nodejs也支持（node中也有全局对象）
- setTimeout
  - 特点：在特定时间后调用一次
  - 语法：let timerId = setTimeout(func|code,  [delay], [arg1]...)
    - func|code 要执行的函数或代码字符串
    - delay 执行前的延迟，以毫秒为单位
    - arg1... 要传入被执行函数的参数列表
  - clearTimeout(timerID)方法
    - setTimeout调用会返回一个"定时器标识符"

- setInterval

  - 特点：按给定的时间周期性执行
  - 语法和参数与setTimeout完全相同

- 定时器的宏任务概览-JS高级

  ```javascript
  function fun(name, age){
    console.log("hello world", name, age) 
  }
  //5s后输出一次hello world
  //Result: hello world kygo 18
  var timerId = setTimeout(fun, 5000, "kygo", "18")
  
  //每5s输出一次hello world
  var timerId2 = setInterval(function() {
    console.log("hello world")
  }, 5000)
  
  //取消定时器
  // clearTimeout(timerId)
  // clearInterval(timerId2)
  ```

   

## 5. BOM

BOM就是提供了一套操作浏览器的API(接口/方法/属性)

### 5.1 认识BOM

- 定义

  - 浏览器对象模型（Browser Object Model），简称BOM
  - 由浏览器提供的用于处理文档之外的所有内容的对象

- BOM主要包括以下对象

  - window：全局对象，包括全局属性、方法

  - location：访问URL信息

  - history ：操作浏览器的历史记录

  - navigator/screen：浏览器相关信息/屏幕窗口信息 （少用）

    

### 5.2 全局对象window

window 代表整个浏览器窗口(BOM中的一个顶级对象(全局))

- 不同视角看待

  - 全局对象
    - ECMAScript中有一个全局对象，这个全局对象在浏览器中叫window，在node中叫global
    - 对于全局对象名称不一致的情况，指定了标准globalThis，且大多数浏览器都支持
  - 浏览器窗口对象
    - 提供了对浏览器操作的相关API

- 一些注意点

  - 放在widow上的所有属性都可以被访问
  - 使用var定义的变量会被添加到window对象上
  - window默认给我们提供了全局的函数和类：setTimeout、Math、Date、Object等

- window的重任

  - 大量属性，localStorage、console、location、history、screenX、scrollX等（60+）
  - 大量方法，alert、scrollTo、close、open等（40+）
  - 大量事件，focus、blur、load、hashchange等（30+）
  - 继承自EventTarget的方法，addEventListener、removeEventListener、dispatchEvent

- 文档地址：https://developer.mozilla.org/zh-CN/docs/Web/API/Window

- 代码示例

  ```html
  <button class="btn">btn</button>
  <script>
    console.log(window === globalThis)  //true
  
    //补充方法
    var btnEl = document.querySelector(".btn")
    btnEl.onclick = function() {
      // window.open("http://www.baidu.com", "_blank")
      //注意: 必须是open打开的窗口才能用close关闭
      window.close()
    }
    //常见事件
    window.onfocus = function() {
      console.log("window获得了焦点")
    }
    window.onhashchange = function() {
      console.log("hash值发生改变了")
    }
  </script>
  ```

  

### 5.3 location对象

- 作用：表示window上当前链接到的URL信息
- 常见属性
  - href  当前URL，可用于获取或设置URL
  - protocol/host/hostname/port  协议/主机地址/主机地址(无端口)/端口
  - pathname/search/hash  路径/查询字符串/哈希值
- 常用方法
  - assign：赋值一个新的URL，并跳转到其中
  - replace：赋值新URL并跳转（没有历史记录）
  - reload：重新加载页面(刷新)，可传入true表示强制清缓存刷新

- URLSearchParams
  - 作用：处理URL的查询字符串
  - 字符串和URLSearchParams类型之间可以相互转换
  - 常用方法
    - get/set：获取/设置参数的值（set有就修改，没有就追加）
    - append：追加一个搜索参数的值
    - has：判断是否有某个参数
  - 注意：中文会用encodeURIComponent和decodeURIComponent进行编码和解码

- 代码示例

  ```html
  <button class="btn">button</button>
  <script>
    //常见属性：属性不仅可读,而且可以设置
    location.hash = "#top"
    location.search = "?name=kygo&age=18"
    //http://127.0.0.1:5500/2-JavaScript/BOM/3.%20location.html?name=kygo&age=18#top
    console.log(location.href)
    //http:  127.0.0.1:5500  127.0.0.1  5500
    console.log(location.protocol, location.host, location.hostname, location.port)
    // /2-JavaScript/BOM/3.%20location.html  
    // ?name=kygo&age=18  #top 
    console.log(location.pathname, location.search ,location.hash)
    
    //常见方法
    var btnEl = document.querySelector(".btn")
    btnEl.onclick = function() {
      // location.reload(true)
      // location.assign("http://www.baidu.com")
      location.replace("http://www.baidu.com")
    }
  
    //URLSearchParams
    var urlSearch = new URLSearchParams("?name=kygo&age=18")
    console.log(urlSearch.get("name"), urlSearch.get("age"))  //kygo 18
    urlSearch.set("height", 1.88)
  
    //编码和解码
    urlSearch.append("addr", "成都")
    //转为字符串
    //name=kygo&age=18&height=1.88&addr=%E6%88%90%E9%83%BD
    console.log(urlSearch.toString())
    //name=kygo&age=18&height=1.88&addr=成都
    console.log(decodeURIComponent(urlSearch.toString()))
  </script>
  ```

  

### 5.3 history对象

- 作用：访问浏览器曾今的会话历史记录
- 属性
  - length/state：记录条数/当前保留的状态值
- 方法
  - back/forward：返回上一页/下一页，等价于 go(-1/1)
  - go：加载具体某页 （传入0代表刷新）
  - pushState/replaceState：打开指定地址/使用replace打开新地址(无记录)
- 应用
  - history和hash是Vue等框架实现路由的底层原理
  - 前端路由核心：修改了URL，不刷新页面

- 代码示例

  ```html
  <button class="btn">btn</button>
  <button class="btn1">btn1</button>
  <script>
    var btnEl = document.querySelector(".btn")
    btnEl.onclick = function() {
      // location.assign("http://www.baidu.com", "_self")
      //传入一个状态/空字符串/url
      history.pushState({name: "kygo"}, "", "#top")
      console.log(history.length, history.state)
    }
    //回到上一个页面
    var btnEl1 = document.querySelector(".btn1")
    btnEl1.onclick = function() {
      history.back()
    }
  </script>
  ```

  

### 5.4 navigator和screen对象

- navigator
  - 作用：表示用户代理-浏览器的状态和标识等信息
  - 属性
    - navigator.userAgent/vendor/platform：浏览器名称/浏览器厂商/浏览器运行的操作系统

- screen

  - 作用：客户端显示器的信息
  - 比如：屏幕逻辑像素 screen.width/screen.height

- 示例

  ```javascript
  //Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) 
  //AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36
  console.log(navigator.userAgent)
  console.log(navigator.vendor)  //Google Inc
  console.log(navigator.platform)  //MacIntel
  
  console.log(screen.width, screen.height)  //1400 900
  ```

  ​     

## 6. JSON

- 什么是JSON
  - 是一种可以在服务器和客户端之间传输的数据格式，不是编程语言
  - JSON全称：JavaScript Object Notation （JavaScript对象符号）
  - 扩展
    - JSON是由Douglas构想和设计的一种轻量级数据交换格式，算是JS的一个子集
    - JSON被提出的时候主要应用JavaScript中，但现在已经独立于编程语言
    - 很多编程语言都实现了将JSON转成对应模型的方法
- 其他传输格式
  - XML
    - 早期的网络数据传输使用XML，但其在解析/传输各方面都弱于JSON，现在已经不使用
  - Protobuf
    - 在网络传输中目前用的越来越多的传输格式，但直到2021年才支持JS，所以目前前端用得较少
- JSON的使用场景
  - 网络数据传输
  - 项目的配置文件
  - 非关系型数据库NoSQL将JSON作为存储格式

- JSON的基本语法
  - JSON顶层支持三种类型的值
    - 简单值 - 布尔值、数字、字符串(不支持单引号)、null
    - 对象值 - key是字符串类型，且必须加双引号，value可以是简单值、对象值、数组值
    - 数组值 - 对象值可以是简单值、对象值、数组值
- JSON序列化
  - 将JS中复杂类型转成JSON格式的字符串
    - 如：想把对象保存到localStorage中（直接存会变成[obj obj]）
  - 序列化方法
    - ES5中引入了JSON全局对象，这个对象中有两个方法
    - stringfy方法 - 将js类型转为对应的json字符串
    - parse方法 - 将json字符串解析为js类型
  - stringfy的参数replacer
    - 传入一个函数，选择性的替换值
    - 传入一个数组，选择性的只包含数组中指定的属性
    - 传入space参数，格式化JSON（了解，用得少）
    - 注意：如果对象有实现toJSON方法，那stringfy会调用toJSON
  - parse方法的参数
    - 可传入reviver函数用于在返回之前对解析的结果执行操作
  - JSON方法可以实现对象的深拷贝（JS高级） 

- 代码示例

  ```js
  //声明一个JS对象
  var obj = {
    name: "kygo",
    age: 18,
    friend: {
      name: "kobe",
      age: "29"
    },
    //如果对象内部有显示声明toJSON方法,那么stringfy会直接调用(了解)
    // toJSON: function(){
    //   return "kygo"
    // }
  }
  //1.1 JS对象直接转化为JSON
  var jsonStr = JSON.stringify(obj)
  console.log(jsonStr)
  //1.2 传入一个函数
  var jsonStr1 = JSON.stringify(obj, function(key, value) {
    //将对象中值为kygo的都转换成kygogo,然后再转JSON
    if(value === "kygo") return "kygogo"
    return value
  })
  console.log(jsonStr1)
  //1.3 传入一个数组
  //选择性返回属性为arr中的项
  var jsonStr2 = JSON.stringify(obj, ["name", "age"])
  console.log(jsonStr2)
  //1.4 space参数
  var jsonStr3 = JSON.stringify(obj, null, 4)
  console.log(jsonStr3)
  
  
  //2.1 JSON转JS
  var Obj1 = JSON.parse(jsonStr2)
  console.log(Obj1)
  //2.2 传入一个函数
  var Obj2 = JSON.parse(jsonStr2, function(key, value) {
    //找出大于等于18的age并增加3
    if(key === "age" && value >= 18) return value + 3
    return value
  })
  console.log(Obj2)
  ```



# JS高级



## 1. this和箭头函数

### 1.1 this的绑定规则

- 注意点

  - 函数在调用时，JS会默认给this绑定一个值
  - this的绑定和函数编写位置无关，和函数调用方式和调用位置有关
  - this是在函数运行时被绑定的
- 绑定规则

  - 默认绑定
  - 隐式绑定
  - 显式绑定
  - new绑定
- 默认/隐式/new绑定如下(学过)

  - 默认绑定-独立函数调用
  - 隐式绑定-通过对象调用
  - new绑定-通过构造函数创建的对象，会执行以下操作
    - 创建一个新对象 => 新对象执行prototy连接(后面讲)
    - 将新对象绑定到构造函数的this上 => 返回这个新对象(如果没有返回其他对象)
  - 代码示例
    ```javascript
    function foo() {
      console.log("foo: " , this)
      // console.log(name, age)
    }
    //1. 默认绑定：this=>全局对象=>window
    foo()
    
    //2. 隐式绑定: this=>调用函数的对象=>obj
    var obj = {
      name: "kygo",
      foo: foo
    }
    obj.foo()
    
    //3. new绑定: this=>new返回的对象=>foo1
    var foo1 = new foo()
    foo1.age = 18
    ```
- **显式绑定**

  - 显式绑定的由来
    - 隐式绑定的前提：对象内部必须有对函数的引用，如一个属性
    - 如果不希望对象内部包含函数的引用，又希望函数的this可以调用对象
  - 显式绑定：明确的绑定函数this指向的对象
  - call和apply方法
    - 所有函数都可以使用call、apply方法
    - 作用：执行函数并且将this绑定到传入的对象上
    - 参数
      - 第一个参数都是传入的对象，第二个参数是函数的参数(apply是数组，call是参数列表)
      - fun.apply(thisArg, [argsArray])
      - fun.call(thisArg, arg1, arg2, ...)
  - bind方法
    - 如果希望函数的this总是绑定到某个对象（而不是使用apply/call调用时才绑定）
    - bind方法作用：创建返回一个新的绑定函数，绑定函数是一个exotic funciton object(怪异函数对象)
    - 参数
      - fun.bind(thisArg[, arg1...] )
      - 新函数的this指向传入的第一个参数，其余参数作为新函数的参数
  - 代码示例
    ```javascript
    function foo(name, age) {
      console.log("foo", this, name, age)
    }
    //Res: foo {info: 'call显示绑定obj'} kygo 18
    foo.call({info: "call显示绑定obj"}, "kygo", 18)
    //Res: foo {info: 'apply显示绑定obj'} kygo 21
    foo.apply({info: "apply显示绑定obj"}, ["kygo", 21])
    //Number {123} 传入基本数据类型会转化为对应的包装类型
    foo.call(123)
    
    //bind绑定: 返回一个绑定this的新函数，可在bind内给新函数传参
    var foo1 = foo.bind({info: "bind绑定"})
    //Res: foo {info: 'bind绑定'} kygo 17
    foo1("kygo", "17")
    ```

### 1.2 内置函数的规则

- 什么是内置函数

  - JS中的内置函数或第三方库的内置函数，要求我们传入另外一个函数
  - 函数不是我们自己显示的调用，而是由内置函数或第三方库帮我们执行

- 例如：setTimeout、onckick、forEach等

- 代码示例
  ```javascript
  //定时器中的this=>window
  setTimeout(()=> {
    console.log(this, "2s~")
  }, 2000)
  
  //事件中的this=>触发事件的元素对象
  var btn = document.querySelector(".btn")
  btn.onclick = function() {
    console.log(this === btn)  //true
  }
  
  var arr = [1, 2] 
  //数组方法中的this=>window
  arr.forEach((item)=> {
    console.log(this)
  })
  //可以显示指定绑定this(注意:这里不能用箭头函数)
  var obj = {name: "kygo"} 
  arr.forEach(function(item) {
    console.log(this)  //this => obj
  }, obj)
  ```

### 1.3 优先级和绑定之外的情况

- 四条绑定规则的优先级

  - 默认绑定的优先级最低
  - 显示绑定(apply/call) > 隐式绑定
  - new绑定 > 隐式绑定
  - new绑定 > bind
    - new绑定不允许和apply/call一起使用
  
- this规则之外的的情况

  - 忽略显示绑定

    - fun.call(undefined/null)                       //call/apply/bind都是这样
    - 如果显示绑定中传入null/undefined，这个显式绑定会被忽略，使用默认绑定
  - 间接函数引用（了解）

    - 函数的间接引用：(bar = obj.foo)()
    - 先赋值，再直接调用函数所以是默认绑定

- 代码示例

  ```js
  //默认绑定优先级最低
  function foo() {
    console.log(this)
  }
  //apply/call > 隐式绑定
  var obj = {foo: foo}
  obj.foo.apply(123)  //Number{123}
  obj.foo.call(321)  //Number{321}
  //bind > 隐式绑定
  var bar = foo.bind(456)  
  var obj = {bar: bar}
  obj.bar()  //Number{456}
  //new > 隐式绑定
  var obj = {foo: function() {console.log(this);this.name = "kygo"}}
  new obj.foo(789)  //foo {name: "kygo"}
  
  //bind > call/apply
  var bar1 = foo.bind(654)
  bar1.apply(100)  //Number{654}
  
  //new > bind
  var bar2 = foo.bind(987)
  new bar2()  //foo{}
  
  
  //绑定规则之外的情况
  foo.call(null)  //window
  foo.call(undefined);  //window
  (bar = foo)()  //window
  ```

  

### 1.4 箭头函数

- 箭头函数介绍（arrow function）

  - ES6之后新增编写函数的方法
  - 箭头函数不会绑定this、arguments属性，不能作为构造函数来使用
- 箭头函数的写法

  - 基本写法
  - 优化写法
    - 只有一个参数时，可以省略()
    - 只有一行代码时，可以省略{}
    - 只有一行代码，表达式的返回值会作为箭头函数的返回值(必须省略return)
    - 返回的是对象，在省略{}的时候，对象必须使用()进行包裹：()=>({name: "kygo"})
- 箭头函数中的this

  - 箭头函数是没有绑定this的
    - 不使用this的四种规则，根据外层作用域决定this
  - this的查找规则
    - 一直往上层作用域查找，找到则使用，否则直到找到全局this为止
- 箭头函数this应用

  - 模拟网络请求

### 1.5 this面试题



## 2. 浏览器渲染原理

### 2.1 网页的解析过程

- **浏览器工作原理**

​		域名 (DNS解析)-> ip地址 ->服务器地址-> 返回index.html(解析)

​		解析过程中有link标签和script标签 -> 到服务器再次下载对应css和js文件 



- 浏览器内核

  不同浏览器有不同内核组成

  Gecko-早期Netscape和Firefox浏览器使用

  Trident-IE4-11浏览器，Edge浏览器已转向Blik

  Webkit-苹果开发的，基于Safari，Google之前也在使用

  Blik-Webkit的一个分支，Google开发，目前应用于Google、Edge、Opera

  浏览器内核-浏览器排版引擎/页面渲染引擎

  

- 浏览器渲染过程

  html遇到js标签->停止解析html->加载执行js代码(js执行是在DOM->DOM Tree过程改变dom)

  html、css解析(Parser) -> DOM Tree+Style Rules -> Render Tree(渲染树) -> Display

  如图：

   ![](C:\Users\Administrator\Desktop\2022\img\js高级_浏览器渲染过程.png)

### 2.2 浏览器渲染流程



### 2.3 回流和重绘解析



### 2.4 合成和性能优化



### 2.5 defer和async属性





## 3. JS运行原理

### 3.1 深入V8引擎原理

- js引擎

  定义：JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中

  浏览器/Node执行js代码  -> 需要js引擎将js代码转换成CPU指令(机器代码)

  引擎举例：

  SpiderMonkey：第一款js引擎，由Brendan Eich开发(js作者)

  Chakra：微软开发

  JavaScriptCore：WebKit中的js引擎，Apple开发(小程序开发常用)

  V8：Google开发的js引擎

  


- 浏览器内核和JS引擎的关系

  - 以Webkit为例，Webkit由两部分组成

  - WebCore ：负责HTML解析、布局、渲染等工作

  - JavaScriptCore：解析、执行js代码(小程序中编写的js就是被JSCore执行的)

    

- V8引擎的原理

  V8是用c++编写的Goole开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等  

  V8可以独立运行，也可以嵌入到任何C++应用程序中

  解析过程：

  源码 -> parse(词法分析、语法分析) ->AST抽象语法树->由Ignition库转换为字节码bytecode

  ->V8将字节码转换成机器指令-CPU代码(不同平台CPU不一样所以需要先转换字节码)运行

  TurboFan库/模块 将多次执行的代码变成优化的机器指令，下次可直接执行

  如图：	

  ![](C:\Users\Administrator\Desktop\2022\img\js高级_V8引擎的原理.png)		

- 代码执行流程分析

  ```javascript
  /*
   1. 代码解析，V8引擎内部会给我们创建一个对象(GlobalObject -> go)
   2. 运行代码
  
  */
  ```

  



### 3.2 JS执行上下文



### 3.3 全局代码执行过程



### 3.4 函数代码执行过程



### 3.5 作用域和作用域链

- **作用域链**

ES6之前作用域链：

​	全局作用域是0级作用域

​	定义函数开启的作用域是1/2/3...级

​	JS会将这些作用域连接起来形成作用域链

​	0->1->2->3->4... (0级作用域里定义的函数就是1级)

 

变量在作用域链查找规则：

​	先在当前找，找到就使用当前作用域的

​	当前没有就去上一级作用域查找

​	以此类推直到0级为止，0级没有找到就报错

 

ES6作用域链：

​	除了定义函数会开启作用域外，代码块也会开启作用域

​    注意点：要用ES6就全部用ES6如：let、箭头函数(不然容易混淆)

​	函数预解析：

```javascript
//ES6之前这种定义函数方式，可以提前调用(会将函数的声明提升到当前作用域最前面)
say()  function say(){}  
//报错，这样只有变量才会预解析
say()  var say=function(){}  
//不会被预解析,let定义的
say()  let say = () => {}  
```







## 4. 内存管理和闭包



### 4.1 JS内存管理



### 4.2 垃圾回收机制算法



### 4.3 闭包的概念理解



### 4.4 闭包的形成过程



### 4.5 闭包的内存泄漏















- **扩展运算符**

扩展运算符在函数形参列表中的作用

将传递给函数的所有实参打包到一个数组中

```javascript
function fun(...arr) {   //将参数打包到arr数组
  console.log(arr); 
}
fun(1, 2)
```

注意：和在等号左边一样，也只能写在形参列表最后 



- **形参默认值**

```javascript
//ES6: 直接在形参指定默认值
function fun(a = 6, b = 6) {
  console.log(a, b);  //Result: 6 6
}
fun()
```

可以将函数作为其他函数的参数和返回值

JS中函数可以嵌套定义(函数中可以定义函数)   



- 对象的属性方法分类

实例属性/实例方法:

​	通过构造函数创建的对象 - 实例对象

​	通过实例对象访问的属性 - 实例属性

​	通过实例对象调用的方法 - 实例方法

静态属性/静态方法:

​	通过构造函数访问/调用的属性/方法就是静态属性和静态方法

​    构造函数也是对象：构造函数.属性=...



**prototype对象** 

可以将构造函数中公共的方法存储到prototype对象中

```javascript
 Person.prototype={say: function(){}}  //里面放构造函数公共方法 
```

prototype对象特点：

​	存储在prototype中的方法可以被对应构造函数创建的所有对象共享(也可存储属性)

​	prototype中出现和构造函数重名属性或方法，访问到的是构造函数中的

应用场景：

​	prototype中一般用于存储所有对象都相同的属性及方法 



- 对象三角恋关系

每个构造函数都有一个默认属性-prototype

prototype中保存着一个对象-原型对象

每个原型对象都有一个默认属性-constructor

constructor指向当前原型对象对应的那个构造函数

通过构造函数创建的对象-实例对象

每个实例对象都有一个默认属性 __proto__ (两下划线)

__proto__ 指向创建它的那个构造函数的原型对象

 

- Function构造函数

​	函数是引用类型(对象)，所有函数都是通过Function构造函数创建的对象

​	构造函数的__proto__比较特殊，指向它自己的原型对象(和prototype一样)

​	Object构造函数  Object原型对象的__proto__为null

​      

- 函数关系完整关系

​      Function函数是所有函数的祖先函数

​      所有构造函数都有一个prototype属性

​      所有原型对象都有一个constructor属性

​      所有函数都是对象

​      所有对象都有一个__proto__属性                 

 ![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps1.png)![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps2.png)

​     ![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps3.png)

​                            -2021.4.3

- **原型链**

  当给构造函数的(.prototype={})赋值时，为了不破坏原有关系

  需要在自定义的对象中手动添加constructor属性，手动指定指向谁(构造函数)

 

  通过 \__proto\_\_ 连接在一起的链叫做原型链

  当使用对象的属性和方法时，自己有用自己的，自己没有去原型中找

  原型没有，就去原型的原型找，一直找到Object的__proto__为NULL为止

  注意：给对象不存在的属性设置值时，不会去原型中查找，会给当前对象新增

 

- **封装/继承/多态**

JS面向对象的三大特性：封装、继承、多态

**封装性**

默认情况对象属性和方法都是公开的，拿到对象就可以操作对象的属性方法

构造函数中let/var设置私有属性，通过this.设置公有方法修改和访问私有属性

**继承**

bind-call-apply三个方法

作用：都是用于修改函数或方法中的this的

obj是新this的指向对象

bind方法：函数.bind(obj ,参数...);  会返回一个修改后的新函数

​     也可以函数传参，只不过参数要写在this对象后面

call方法： 函数.call(obj ,参数...);  会立即调用新函数  可传参

apply方法：也是立即调用，但传递参数格式不一样，通过数组传参

​      函数.apply(obj ,[参数...]);  

修改方法的this：方法.bind() 一样的做法...

JS继承的终极方法：

  在子类的构造函数中通过call借助父类的构造函数

  将子类的原型对象修改为父类的实例对象\



**多态**

强类型语言-变量使用严格符合定义：int就存储整型

弱类型-不要求变量使用严格符合-JS就是弱类型

弱类型语言不关注多态





- 数组解构赋值 

ES6新增赋值方法，左边右边格式必须相同，才能完全解构

```javascript
//左右边个数可以不一样，会赋值undefined或者多余值丢弃
let [a,b,c]=[1,2,3]
let [a,b=666,c=1]=[1] //可以给左边的值指定默认值 

//ES6扩展运算符：在最后一个字母前加... 可以将多余数据打包
let [a,...b]=[1,2,3] 
```



- **函数防抖**

函数防抖是优化高频率执行js代码的一种手段

​    可以让被调用的函数在一次连续的高频操作过程中只被调用一次

​    作用：减少代码执行次数,提升网页性能

​    应用场景：oninput/onmousemove/onscroll/onresize等事件

- **函数节流**

​	作用和函数防抖一样

​     区别：函数节流是减少连续的高频操作函数执行次数

(例如连续调用10次,可能只执行3-4次)

​        函数防抖是让连续的高频操作时函数只执行一次

(例如连续调用10次,但只会执行1次)







- ES6

常量：整形、实型、字符串、布尔、自定义常量(ES6: const关键字/不能改变)

```javascript
1 1.2 "2" true 
const name="cth";
```

预处理(解析)：将所有变量和函数的定义放到所有代码最前面，所以可以先使用再定义变量

```javascript
console.log(a);  //undefined
var a = 1;
```

ES6变量定义：let 变量名称;

```javascript
let a=1;
```

注：let定义过的变量重新定义报错(方便查找)，而老版本的var不会

​		let定义的变量不会预解析，必须先定义再使用，否则会报错

补：字面量是具体的值，存储在常量或变量中
